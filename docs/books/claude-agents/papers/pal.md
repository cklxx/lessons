# PAL：把推理变成可执行程序

原文链接： [PAL: Program-aided Language Models](https://arxiv.org/abs/2211.10435) [67]

## 主旨
PAL 的主旨是让语言模型输出可执行程序，而不是直接输出答案。通过“先生成代码、再运行得到结果”的方式，模型把复杂推理外包给执行器，从而提高可验证性与稳定性，尤其适用于算术与符号推理场景。[67]

## 背景与问题定义
论文聚焦于链式思考在算术与符号推理中的不稳定性：模型即便能写出正确思路，也常在计算细节上出错。PAL 希望将“思路”与“计算”分离，让模型只负责产生可执行结构，把具体运算交给更可靠的执行器。[67]

## 方法与机制
论文提出 Program-aided Language Models：模型在提示中被要求生成简洁程序（通常是 Python 或伪代码），程序负责具体计算或检索逻辑，最终答案由执行器给出。模型不需要完成所有计算细节，只需给出正确的逻辑结构，执行器保证结果一致性。该设计将自然语言推理拆解为“规划（代码）”与“执行（解释器）”两个阶段。[67]

## 实验与结果
作者在多种复杂推理任务上验证 PAL 的优势，包括算术推理与多步问题。结果表明，PAL 在这类任务上的准确率显著提升，且错误更易定位：一旦答案不对，往往源自程序逻辑而非隐式语言推理。实验强调 PAL 的稳定性和可复现性，而不仅仅是单次得分。[67]
论文还展示了程序中间表示的诊断价值：相比纯语言输出，程序更便于调试与局部修复，使得错误分析与迭代成本显著降低。这为工程上建立“可解释的推理轨迹”提供了实证依据。[67]

## 工程启示（优化点）
- 用程序作为中间表示，减少语言模型在数值细节上的负担。
- 把执行环境标准化，确保同一程序在不同运行时结果一致。
- 提示中强调“先写程序再求解”，并限制输出格式。
- 对程序执行异常设定回退策略，避免单次失败中断流程。

## 局限与延伸
PAL 更擅长结构化问题，对开放式、缺乏明确计算逻辑的任务收益有限。程序生成也可能带来安全与依赖风险，需要在沙箱或受限运行环境中执行。延伸方向包括：引入程序验证、与工具检索结合、以及在真实产品中把“生成程序”作为可审计的中间产物。[67]
