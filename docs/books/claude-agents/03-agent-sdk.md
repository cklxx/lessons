# 第 3 章：Agent SDK 是运行时，不是包装

Agent SDK 把 Claude Code 的运行时拆成了可编程的积木：你不是在“调用模型”，而是在控制一个带工具、带上下文、带状态的循环。官方把它叫作 agent loop，本质上是“输入 → 决策 → 工具 → 结果 → 下一步”的持续过程。理解这点之后，你会把 SDK 当作一个小型运行时，而不是一个轻量封装。[19][20]

工程文章把这个循环讲得更具体：先收集上下文，再执行，再验证，然后再进入下一轮。这个顺序决定了 SDK 的用法不是“写好 prompt 然后等结果”，而是把任务拆成可反复执行的小步，每一步都有可观察的输入与输出。[55]

在具体使用上，SDK 提供了 Python 与 TypeScript 的参考实现，并且对 TypeScript 有新版接口预览。它们的差异主要是语法风格，核心能力是一致的：同样的工具机制、同样的权限体系、同样的会话管理方式。[21][22][23]

运行时最关键的是“可控”。官方文档把技能、子代理、hooks 和权限分成不同层次，是为了让你在不同粒度上限制模型行为。技能让知识与步骤可复用，子代理让任务拆分更清楚，hooks 让你在调用前后插入检查，权限配置保证模型只能看到你允许的工具。这些并不是附属功能，而是让 agent 可被工程化治理的主干。[24][25][26][27]

在 agent loop 的第一步，SDK 鼓励模型用文件系统和工具自己找上下文，而不是一次性塞满 prompt。工程文章里提到“给模型一台电脑”的设计逻辑：它可以用搜索、脚本和文件组织来形成自己的工作记忆。必要时再用子代理做并行检索，主代理只接收有用的片段，从而把上下文压缩成真正能用的线索。[55][25]

当你需要引入自定义能力时，SDK 的自定义工具与 MCP 集成把外部系统变成标准化工具。这样做的好处是，你仍然在同一套工具契约里管理行为，而不是在多个系统之间反复写胶水代码。[28][29]

输出侧也有明确的工程抓手。Structured outputs 让模型产出可以被程序解析的结构；成本与 usage 追踪让你知道一次任务的资源消耗；文件 checkpointing 提供可回溯的编辑记录；流式与单次模式的区分则决定了交互体验与吞吐效率。这些能力共同定义了“可测试、可审计、可回滚”的运行时体验。[30][31][32][33][34]

验证步骤同样可以被工程化：规则检查、视觉反馈、LLM 评审都可以成为 agent loop 的一部分。工程文章提醒，模型如果没有清晰的验证目标，就会把“看起来完成”当成完成；而把验证做成工具或规则之后，模型才会学会在收尾前再确认一次。[55]

此外，SDK 还提供了 slash commands、plugins、系统提示修改、托管与安全部署、迁移指南和任务清单等功能，这些更接近“产品化”一侧：它们把 agent 从单人实验带到稳定的团队生产环境中。[35][36][37][38][39][40][41]
