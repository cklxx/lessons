# 第 2 章：工具是合同，不是魔法

工具在官方体系里的位置非常清晰：它是一个被结构化定义的接口，模型只能通过这个接口去“请求”外部能力。最小定义包含名字、描述和输入 schema；描述写得越清楚，模型就越知道什么时候该用、什么时候不该用。你可以把它理解为“对模型开放的一小扇窗”，窗外是系统能力，窗内是严格格式。[4][5]

工具调用的语义也不是“模型直接执行”。模型会先发出 tool_use 请求，你的系统或运行时真正执行工具，再把 tool_result 反馈给模型。这一来一回决定了工具的可控性：错误要结构化、返回要可检验，否则模型很难持续学会正确使用。对于长耗时工具，官方提供了更细粒度的流式协议；对于需要在代码环境中再调用工具的场景，还提供了 programmatic tool calling 的路径，这意味着你可以把复杂的数据流塞进一个受控容器里，而不是把所有逻辑都塞进 prompt。[6][7]

当工具数量上升到几十甚至上百时，工程侧的策略也在变化：不再把所有工具定义一次性塞进上下文，而是让模型按需检索、按需加载。Tool Search Tool 的思路是先只暴露一个“找工具”的入口，其余工具延迟加载；Programmatic Tool Calling 则把循环、筛选与数据整理交给代码执行环境，只把真正需要的结果放回上下文。两者合起来，让“工具很多”不再等于“上下文拥堵”。[54]

工程博客进一步强调：工具不是给开发者用的接口，而是给不确定性很高的 agent 用的接口。要让它好用，就要像训练同事一样去设计和检验。少而准的工具集合、明确的命名边界、紧凑的返回格式、清晰的错误语义，都会让 agent 更稳定。评测不是锦上添花，而是用来发现“描述不清”和“参数含糊”这些隐性问题的放大镜。[65]

当工具链条拉长、决策依赖前序结果时，官方还提出 “think” 工具作为一个显式的停顿点，让模型把关键规则、缺失信息和下一步检查写出来。后来他们更推荐使用 extended thinking，但核心思想一致：在复杂链路里给模型一个可被调用的思考层，而不是只靠隐含推理。[58]

技能体系把“工具合同”再推进一步：Skill 是一套可复用的文件夹结构，包含 SKILL.md 以及额外的脚本与资料，通过分层加载控制上下文的体积。核心思路是把团队的流程和约定写成一个可被读取、可被执行的目录结构，让模型在需要时加载，而不是每次都靠对话重复讲解。[1][3][63]

内建工具可以理解为几类“现成通道”。Web search 和 web fetch 负责把外部信息引入上下文，tool search 是帮助模型在大量工具中快速定位目标；memory 是跨会话的随身便签；code execution 提供受限计算环境；bash 和 text editor 则是对本地文件和命令的精细操作；computer use 更像远程操控一个屏幕，让模型以 UI 交互的方式完成任务。它们覆盖了信息、计算、文件与交互四个维度，但每一种都要求你明确边界和权限配置，因为模型只会按照你定义的合同行事。[8][9][10][11][12][13][14][15]
