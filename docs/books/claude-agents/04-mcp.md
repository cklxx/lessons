# 第 4 章：MCP 把工具接入变成协议

在没有统一协议的情况下，每接一个外部系统都要写一套定制接口：权限、鉴权、字段、错误语义都不一样。MCP 的意义是把这些差异压缩成一个标准层，让 agent 把“外部系统”当成统一的工具集合来使用。官方文档里的 MCP connector 与 remote MCP servers 就是在回答“怎么接”和“怎么管”两个问题：前者让你把 MCP 工具接进模型调用，后者让你把多个外部系统统一成可治理的服务端口。[16][17]

modelcontextprotocol.io 把 MCP 定位成开放协议，强调工具与上下文之间的标准化契约。对应的博客与公告进一步说明了它的生态方向：一方面是降低接入成本，让更多工具能够被模型安全地调用；另一方面是通过开放治理避免单点绑定，让协议可以被更广泛的生态接受。[18][44][45]

当 MCP 工具数量增多时，工程侧的挑战从“能不能接”变成“怎么让模型只看到需要的部分”。工程文章提出把工具包装成可执行代码：把每个工具映射成文件，模型用文件系统找工具，再用代码执行批量调用与筛选，把真正有用的结果写回上下文。这样做的好处是工具定义和中间数据不会直接塞满上下文，工具规模可以扩到上百上千。[59]

MCP 也在客户端体验上做了工程化补齐。Desktop Extensions 把本地 MCP server 打包成可安装的扩展，用一键安装替换手动配置，让非开发者也能接入工具。它本质上是把“协议”变成“分发形式”，让 MCP 更接近日常可用的能力，而不是停留在工程师层面。[60]

把 MCP 放进 agent 体系里，你会发现它其实是“接口治理”的延伸：你把所有外部能力都压缩成统一的协议，再通过权限与运行时策略去限制模型行为。这样，扩展能力的成本下降了，但可控性并没有被稀释。[16][17][18]
