# 第 1 章：什么是 Agent，什么不是

把 agent 想成一个会主动决定下一步的执行者：它接到目标后，会自行判断该问什么、该调用什么工具、什么时候停下。相对地，workflow 更像一条流水线，步骤是事先固定好的，模型只是在每个关卡完成指定任务。二者的差异不在“聪明不聪明”，而在“决策权在哪里”。这也是官方研究反复强调的分界线：当任务结构不确定、需要动态分解和回溯时，agent 才有价值；当流程足够稳定时，workflow 更简单、更稳定。[42]

理解这一点有两个直接好处。第一，你不必把所有任务都推到 agent 上；越是确定性的流程，越应该把决策压回到工程和人类规则里。第二，你可以把 agent 的责任边界写得更清楚：它负责探索、试错与整合，但不负责越过你给定的边界。这种边界感会在后续的工具契约、权限控制和运行时治理里反复出现。[19][42]

在这个框架里，Agent Skills 更像“可复用的工作指引”。它不是一次性的提示词，而是一个文件夹：里面有说明、有脚本、有模板，模型在需要时加载，像新人入职时翻看团队手册。官方文档要求 Skill 有明确的名字和描述，是为了让模型知道什么时候该用它；描述越清楚，触发越稳定。这样的设计让技能可以被积累、被复用，也让你不用在每次对话里重复“如何做这件事”。[1][2][3]

如果你用的是 Agent SDK，这种“技能即目录”的组织方式会更明显：技能既可以被 Claude Code 使用，也能被 SDK 引入到更大规模的运行时里。它们是可组合的积木，不是单次会话的临时记忆。理解这一层，你就不会把 Skill 当成神秘的 prompt，而是把它当成产品团队的标准作业说明。[19][24]
