# 第 8 章：前端实现：状态、可恢复与体验指标
![第 8 章封面](../../assets/chapter_08_header_1766035606171.png)

> 前端不是把页面写出来，而是把体验写成一个可预测系统：用户知道下一步是什么，失败知道怎么回来，系统知道怎么解释自己。[17]

在 AI 产品里，前端更像驾驶舱：它既承载交互，也承载不确定性。你需要让用户看到证据、看到进度、看到边界，而不是只看到一个看似聪明的输出框。

## 章节定位
本章承接上一章的工程化纪律，聚焦把 UI 规格落到可回归的前端实现：组件化、状态完整、错误可恢复、体验可度量。[17]

## 你将收获什么
- 一套前端状态完整性方法：空/加载/成功/失败/无权限不是细节，是系统边界。[17]
- 一套 AI 交互的三件套：进度（可预期）、证据（可追溯）、反馈（可学习）。
- 一份体验指标最小集合：把更好用变成可观察的门槛，而不是审美争论。[6][17]

## 三层思考：前端要处理的不只是交互
### 第 1 层：读者目标
你要交付的是可用且可解释的体验：用户完成任务更快、更稳，并且在失败时能自救。

### 第 2 层：论证链条
体验稳定的链条是：

状态齐全 → 错误语义一致 → 进度可预期 → 结果可采纳（保存/导出/回溯）→ 反馈可回流 → 指标可裁决

### 第 3 层：落地与验收
前端是否做好，看三件事：
- 关键路径是否可回归（至少覆盖一次闭环）；
- 失败是否可恢复（用户不求助也能继续）；
- 体验是否可度量（至少有 1 个效率指标与 1 个质量指标）。[6][17]

## 方法论速览：把状态当成产品的一等公民
![图 8-1：前端体验系统（状态矩阵→错误恢复→证据/进度/反馈）示意](../../assets/figure_08_1_1765971017361.png)

### 1) 状态矩阵：每个关键页面都必须过五态门槛
把每个关键页面写成状态矩阵，缺一项视为未完成。[17]

#### 页面状态矩阵

| 页面 | 空 | 加载 | 成功 | 失败 | 无权限 | 恢复入口 |
| --- | --- | --- | --- | --- | --- | --- |
| 核心任务页 | 有 | 有 | 有 | 有 | 有 | 重试/返回/求助 |

### 2) 错误语义：把报错改成可行动信息
前端最常见的浪费，是把错误提示写成技术真相，却不给用户行动路径。推荐把错误提示改写成三段式：
- 发生了什么（可理解）
- 为什么可能发生（可选）
- 你现在能做什么（必须给入口）

对 AI 产品，还需要把错误分成可恢复与不可恢复两类，并区分是模型问题、证据问题还是权限问题。否则用户只会把所有失败都理解成系统不行。

| 类别 | 典型触发 | 用户看到的提示重点 | 恢复入口（必须） |
| --- | --- | --- | --- |
| 证据不足 | 检索不到/引用不够 | 需要补信息或上传资料 | 追问/上传/切换范围 |
| 拒答 | 风险请求/越界 | 为什么不能做，能做什么替代 | 给替代方案/改写请求 |
| 生成质量差 | 自相矛盾/无引用强答 | 不确定性提示 + 要求核验 | 一键纠错/重新生成/切换保守模式 |
| 预算/超时 | token/时延越界 | 当前进度与下一步选择 | 取消/降级/继续等待 |
| 权限不足 | 没有访问权限 | 缺什么权限与申请路径 | 申请权限/切换账号 |

### 3) AI 交互的三件套：进度、证据、反馈
AI 场景里，用户不确定性更高，因此必须把不确定性可视化：
- **进度**：让用户知道系统在做什么、还要等多久、是否可取消。
- **证据**：当输出基于资料或工具调用时，展示来源与依据（哪怕是简化版）。[6]
- **反馈**：允许用户一键标注有用/无用/危险，并把样本沉淀到失败样本库。[18]

#### AI 输出区的最小结构

| 区块 | 目的 | 最小要求 |
| --- | --- | --- |
| 结果 | 给出可采纳的答案/动作 | 可复制/可保存/可导出 |
| 依据 | 告诉用户为什么 | 引用/来源/关键输入摘要 |
| 边界 | 告诉用户何时不该信 | 不足时拒答/追问/提示风险 |
| 反馈 | 让系统变聪明 | 一键反馈 + 失败样本记录 |

![图 8-2：AI 输出区的信息架构与交互](../../assets/figure_08_2_ai_output_ui_structure_1766374303345.png)

!!! note
    作图提示：建议画成一个聊天或结果页的分区示意，能一眼看到进度、结果、依据与反馈入口。
    - 上：进度（正在检索/正在调用工具/生成中）+ 可取消
    - 中：结果（可复制/可保存/可导出）+ 关键结论优先
    - 下：依据（引用卡片/工具调用摘要）+ 可折叠
    - 底部：边界提示（何时不可靠/何时需要更多信息）+ 一键反馈

把这四块落到界面上，用户才会看见系统的边界，进而敢把它放进工作流：

```text
[进度：检索/调用工具/生成中…]（可取消）

[结果：结论优先]（可复制/可保存/可导出）

[依据：引用卡片/工具摘要]（可折叠）

[边界提示：何时不可靠 + 下一步怎么做] + [一键反馈]
```

### 最小实现骨架：把输出区做成状态机
实现层面，AI 输出区最好按状态机组织，而不是用零散的布尔值拼凑。否则流式输出、取消、重试、引用卡片展开等交互会迅速把代码变成不可维护的条件分支。

下面是一份极简的类型骨架，用来约束状态、证据与事件（示意，不绑定框架）：

```ts
type Phase = 'idle' | 'running' | 'done' | 'aborted' | 'error'

type Evidence = {
  source_title: string
  source_url: string
  snippet: string
  score: number
}

type OutputState = {
  phase: Phase
  answer: string
  evidences: Evidence[]
  trace_id: string
  started_at_ms: number
  first_token_at_ms?: number
  finished_at_ms?: number
  error_code?: string
}
```

### 4) 体验指标：用最小集合建立裁决
0→1 不追求指标齐全，只追求能裁决。建议最小化为：
- **效率指标**：完成一次闭环的耗时、步骤数。
- **质量指标**：失败后恢复率、关键错误率。
- **守门指标**：崩溃率、卡顿、成本/延迟（与后端口径一致）。[6]

前端需要把指标变成可采集事件，否则验收永远停留在感觉。最小事件表可以只包含 6 个：

| 事件 | 何时触发 | 用来算什么 |
| --- | --- | --- |
| task_started | 用户开始一次任务 | 任务量与漏斗入口 |
| first_token | 首次流式字符出现 | 首 token 延迟 |
| answer_done | 输出完成 | 端到端耗时 |
| evidence_expanded | 用户展开依据 | 证据可用性与信任 |
| user_feedback | 有用/无用/危险 | 质量信号与失败样本 |
| task_completed | 结果被采纳（保存/导出/继续） | 采纳率与闭环完成率 |

## 关键流程图（纯文本）：前端把不确定性做成可控体验

```text
状态矩阵（空/加载/失败/无权限+恢复） -> AI 输出区三件套（进度/证据/反馈）
  -> 事件打点（最小 6 事件） -> 失败样本沉淀（可回放）
    -> 体验对比表（效率/质量/守门） -> 裁决（保留/回滚/继续）
```

## 示例（可复制）：输出区三件套 + 失败样本沉淀

**目标：** 让用户在等待、失败与不确定时仍能推进，并把失败变成回归资产。

**前置条件：**
- 你有一个关键页面（核心任务页）与一个最小输出状态结构（见本章类型示例）
- 你能在项目里保存失败样本与对比表

**输出格式：**
- 输出区结构说明：`docs/frontend/output-area.md`
- 事件表与口径：`docs/frontend/events.md`
- 失败样本：`reports/frontend/failures.jsonl`
- 体验对比表：`reports/frontend/compare.md`

**步骤：**
1. 把输出区固定成三件套：进度（可取消）、证据（可展开）、反馈（可回流）。[6][18]
2. 事件最小化：只打最关键的 6 个事件，保证每个事件都能回答一个裁决问题（效率/质量/守门）。[6]
3. 失败样本沉淀：当用户点无用或危险，或出现错误码时，把最小上下文与 trace_id 记录成 JSONL。[18]
4. 迭代只改一个断点：每次改动用同口径对比表裁决（保留/回滚/继续）。[6]

**验证命令：**
```bash
python3 - <<'PY'
from pathlib import Path

events = Path('docs/frontend/events.md')
if not events.exists():
  raise SystemExit('missing docs/frontend/events.md')

text = events.read_text(encoding='utf-8', errors='replace')
must = ['task_started', 'first_token', 'answer_done', 'evidence_expanded', 'user_feedback', 'task_completed']
missing = [k for k in must if k not in text]
if missing:
  raise SystemExit(f'missing events: {missing}')

print('ok')
PY
```

**失败判定：**
- 用户失败后无自救入口（只能重试或放弃），或无法定位到错误码与 trace_id。
- 没有失败样本与对比表，只能靠感觉说体验更好了。[6]

**回滚：**
- 回到上一稳定 UI 行为与埋点口径；把触发样本写入回归集，直到同口径复跑通过再继续迭代。[6]

## 复现检查清单（本章最低门槛）
- 状态矩阵可执行：关键页面空/加载/成功/失败/无权限齐全；失败与无权限都有恢复入口。[17]
- 失败样本可沉淀：AI 输出区具备进度/证据/反馈三件套；至少沉淀 10 条失败样本并可回放复盘。[18]
- 体验对比可裁决：改动前/后同口径对比效率/质量/守门指标，并给出结论与回滚条件。[6]

## 常见陷阱（失败样本）
1. **现象：** 页面能用，但用户很慢、很不确定。  
   **根因：** 缺少进度与边界表达，用户不知道系统在做什么，也不知道什么时候该停。  
   **复现：** 用户输入后长时间等待，无进度与可取消入口；失败时只能重复提交。  
   **修复：** 补齐进度与取消、补齐边界提示，把等待变成可预期，并给出下一步建议。  
   **回归验证：** 首 token 延迟、端到端耗时与失败后恢复率在同口径对比中改善，且守门指标不退化。[6]

2. **现象：** 错误提示很多，但用户仍然放弃。  
   **根因：** 错误不可行动；没有恢复入口或恢复入口不显眼。  
   **复现：** 错误提示只写失败或未知错误，用户不知道该改输入还是该重试，也不知道是否已保存现场。  
   **修复：** 把错误提示改成三段式（发生了什么/你能做什么/系统已做什么），并提供明确恢复入口与 trace_id。  
   **回归验证：** 同一错误场景下用户能在一次恢复动作后继续推进；工单量与重复失败下降。

3. **现象：** 看起来更好用了，但指标不动。  
   **根因：** 没有定义效率与质量口径；优化对象漂移，把细节精修当成进度。  
   **复现：** 改动后缺少同口径对比表，无法回答闭环更快了还是更可靠了。  
   **修复：** 用最小指标集建立裁决；无对比表不宣称提升；每次只改一个断点。[6]  
   **回归验证：** 每次迭代都能给出效率/质量/守门的同口径对比与结论（保留/回滚/继续）。[6]

## 交付物清单与验收标准
- 关键页面状态矩阵与恢复入口说明。[17]
- AI 输出区结构说明（进度/证据/边界/反馈）。[6]
- 体验对比表（效率/质量/守门指标）与结论（保留/继续/回滚）。[6]

## 下一章
前端解决体验如何可预测。下一章进入后端：把错误语义、幂等、审计与可观测做成系统默认属性。见：[09-backend.md](09-backend.md)。

## 参考
详见本书统一参考文献列表：[references.md](references.md)。
