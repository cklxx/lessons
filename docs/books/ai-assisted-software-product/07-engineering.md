# 第 7 章：工程化与编码：让 AI 的速度可控
![Chapter 7 Header](../../assets/chapter_07_header_1766035588900.png)

> AI 能让你写得更快，也能让你更快地写错。本章的核心原则：用门禁约束速度，用审查保护一致性，用回滚对冲不确定性。[5][6][18]

当你一个人推进全链路时，工程化不是奢侈品，而是保险：它让你敢快、敢改、敢上线。没有门禁与回滚，AI 会把你带向另一种极端——看似进度飞快，实际上债务滚雪球。

## 章节定位
本章位于产品与体验之后、前后端实现之前。它解决的不是具体技术选型，而是交付纪律：如何把 AI 的输出变成可验证、可审计、可回滚的变更，从而让你在 0→1 的速度与稳定性之间找到平衡。[5]

## 你将收获什么
- 一条补丁优先的工作流：任何 AI 输出都先落成可审查的最小变更，再谈扩展。
- 一份最小质量门禁：什么情况下必须阻断合并/发布，什么情况下允许灰度试错。[6]
- 一套回滚与留档协议：退化如何被发现、如何回滚、证据如何归档，避免事后讲故事。[18]

## 三层思考：工程化的真正目标
### 第 1 层：读者目标
你要获得的不是更漂亮的仓库，而是三种能力：
- 你能持续交付小步改动，而不是憋大招。
- 你能在退化出现时快速定位与回滚。
- 你能把每次改动的证据留下来，让未来的自己能复盘。[5][6]

### 第 2 层：论证链条
把 AI 纳入工程化链条，顺序必须反直觉：**先定义约束，再允许生成**。

门槛与口径 → 最小变更范围 → 生成补丁 → 自动检查（快到慢）→ 人工审查（风险点）→ 灰度发布 → 观测与回滚 → 归档

只要你跳过第一步（门槛与口径），后面每一步都会变成解释工作。[6]

### 第 3 层：落地与验收
工程化是否成立，看三件事：
- 你是否能把一次 AI 生成收敛为可审查的小补丁；
- 你是否能用一致口径判断更好/更坏/不变；
- 你是否能在退化时一键回滚。[6]

## 方法论速览：把 AI 输出变成可交付变更
![图 7-1：AI 参与交付的门禁链路（约束→补丁→检查→审查→灰度→回滚）示意](../../assets/figure_07_1_1765970987245.png)

![图 7-2：工程化闭环（门禁→证据→灰度→观测→回滚）](../../assets/figure_07_2_engineering_gates.svg)

### 1) 先写门禁：什么情况下必须阻断
把门禁写在你能执行的地方。建议最小化但强硬：
- **正确性门禁**：关键路径回归不过，禁止合并。
- **风险门禁**：越权、敏感数据暴露、注入风险命中，禁止发布。
- **守门指标**：延迟/成本/错误率越界，必须回滚或降级。[6]

**模板：最小质量门禁（按项目裁剪）**

| 类别 | 你要守住什么 | 失败判定（阻断条件） |
| --- | --- | --- |
| 功能正确性 | 关键路径可回归 | 回归失败即阻断 |
| 安全与权限 | 越权不可发生 | 任一越权样本命中即阻断 |
| 稳定性 | 错误可定位可恢复 | 错误率/崩溃率上升且无豁免 |
| 成本与性能 | 不为变聪明付无限代价 | 成本/延迟越过阈值即回滚 |
| 可审计性 | 关键行为可追溯 | 缺关键日志/审计字段即阻断 |

### 1.2) 把门禁做成一条命令（否则很快就会形同虚设）
门禁，就像是代码世界的安全检查员。把它写在文档里很容易，但真正难的是让它在每一次改动中都切实地发挥作用。在繁忙的开发工作中，面对一堆分散的规范和检查项，你很容易会不自觉地忽略其中一两项，或者觉得这次先不跑了，下次再补。长此以往，再完善的规则也会形同虚设。

对个人项目而言，与其一上来就搭一个复杂的 CI 系统，不如先采取一个更简单、更直接、也更有效的策略：把所有必须通过的检查收敛为**一条可重复执行的命令**。这条命令就像你的一键发车按钮：每次合并/发布前你只需要跑它；它失败，你就停下来修，而不是解释为什么可以忽略它。

你可以把它想象成飞行员的起飞前检查：如果起飞前有几十个项目需要手动核对，即使最有经验的人也可能在压力下遗漏。但如果有一个运行所有系统自检的按钮，按下后所有检查都会自动完成并给出明确结果，那么安全性会显著提高。你要做的，就是给自己的项目也造一个这样的自检按钮。

本仓库提供了一个最小化的门禁脚本，它只做两件事（引用一致性检查 + 严格构建检查）。但它的核心价值不在于检查了多少项，而在于它把交付纪律转化为一种低摩擦的默认行为：当 AI 极大地加速了你的产出速度时，这条门禁就负责把高速的变更力量，安全地收敛成可控、可靠的质量。

```bash
python3 tools/run_quality_gates.py
```

### 1.5) 把门禁量化：用 DORA 指标校准提效[6]
当你引入 AI 编码后，最容易出现的错觉是提交变多 = 效能变高。真正可长期成立的提效，应该能同时改善速度与稳定性；否则只是把风险和返工推迟到线上。[6]

**DORA 四个核心指标（团队级，别做个人 KPI）**
- **部署频率（Deployment Frequency）**：你能多快把价值送到用户手上。
- **变更前置时间（Lead Time for Changes）**：从提交到上线要多久。
- **平均恢复时间（MTTR）**：出事后多久恢复服务。
- **变更失败率（Change Failure Rate）**：发布导致故障/回滚的比例。[6]

**最小落地：把门禁与指标对齐**
- 每个门禁都能映射到指标：回归/静态检查守 **变更失败率**；可观测与一键回滚守 **MTTR**；小步提交与主干合并守 **Lead Time**。[6]
- 任何提速都必须配对恢复能力：没有回滚/降级，就不要追求更高部署频率。[6]

### 2) 约束生成：把 AI 当生成器，不是裁判
最常见的失败是：让 AI 自己决定改哪里、改多少、怎么验收。你要做相反的事：先把边界写清楚，再允许它填空。

**模板：AI 编码任务卡（补丁优先）**

| 字段 | 写法（越具体越好） |
| --- | --- |
| 目标 | 一句话：要改变的行为是什么 |
| 范围 | 允许改哪些文件；禁止改哪些模块 |
| 输入上下文 | 只给必要片段；不塞无关代码 |
| 输出格式 | 只允许输出可审查的补丁与变更摘要 |
| 验收门槛 | 哪些回归必须通过；哪些指标必须不退化 |
| 风险点 | 权限/成本/数据边界；越界即失败 |
| 回滚 | 如何关掉/降级/回退到旧行为 |

### 3) 小步提交：一次只解决一个问题
AI 很擅长把事情一次做完，而工程交付需要的是把事情一次做对。原则是：
- 每个变更都能独立解释、独立验证、独立回滚。[5]
- 每个变更都以证据结束：对比表、回归结果、风险说明。[18]

### 4) 人工审查只看高风险点
在门禁健全的情况下，人工审查不应该花在格式与风格上，而应该聚焦：
- 边界是否被扩大（多改了不该改的地方）；
- 错误与权限是否被正确处理；
- 回滚与降级是否真实可用；
- 成本是否可能被放大（循环调用、无预算上限）。[6]

**模板：高杠杆审查清单**
- 变更是否只做了一件事？是否可回滚？
- 是否新增了新的失败模式？失败后用户如何恢复？
- 是否触及权限/计费/数据边界？审计是否完整？
- 是否可能导致成本/延迟爆炸？是否有预算与停止条件？[6]

### 5) 合规与风险：把不可说变成默认约束
AI 辅助编码最容易踩的不是语法，而是边界：隐私、密钥、第三方代码与许可证、内部机密信息。[19]

最低纪律：
- 不在提示里泄露敏感信息；对日志与样本做脱敏。
- 任何复制来的实现都要做来源与许可证检查；不把不明来源代码当成可用资产。[19]
- 关键模块（鉴权/计费/审计）默认更严格：小步、强门禁、强回滚。

## 复现检查清单（本章最低门槛）
- 你能用任务卡把一次 AI 输出约束成可审查的小补丁。
- 你有一份最小门禁表，并且知道每条门禁的失败判定与回滚动作。[6]
- 你能为最近一次改动写出证据：通过/退化的同口径对比与结论。[18]

## 常见陷阱（失败样本）
1. **现象**：进度很快，但越来越不敢改。  
   **根因**：没有门禁与回滚，改动不可预测。  
   **修复**：先补回归与守门指标，再谈提速；把可回滚作为硬条件。[6]

2. **现象**：AI 一次改了一大片，审查成本爆炸。  
   **根因**：没有范围约束，把生成当作交付。  
   **修复**：改为小步补丁；禁止跨模块改动；一次只解决一个问题。[5]

3. **现象**：线上出现成本/延迟突然飙升。  
   **根因**：缺少预算与停止条件；把更聪明当成更应该做。  
   **修复**：为关键链路设置预算上限与停止条件；越界即降级/回滚。[6]

## 交付物清单与验收标准
- AI 编码任务卡（至少 3 张，覆盖常见工作：修 bug、加功能、重构）。
- 最小质量门禁表（按项目裁剪）与对应回滚动作。[6]
- 变更证据留档：对比表、回归结果、风险说明与决策记录。[18]

## 下一章
工程化解决怎么安全地改。下一章开始进入具体实现：先从前端把体验与状态做成可回归系统。见：[`08-frontend.md`](08-frontend.md)。

## 参考
详见本书统一参考文献列表：[`references.md`](references.md)。
