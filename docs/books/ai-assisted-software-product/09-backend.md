# 第 9 章：后端架构：边界、幂等与可观测
![第 9 章封面](../../assets/chapter_09_header_1766035625708.png)

> 后端不是把接口跑通，而是把风险关在笼子里：错误语义一致、请求可重放、成本可止损、事故可追责。[5][6]

0→1 的后端常见两种失败：一种是能跑但不稳，另一种是稳但太贵。AI 让第二种更常见：一次看似无害的改动，可能把调用次数、上下文长度或工具链路放大，成本与延迟像潮水一样淹没你。[6]

## 章节定位
本章承接前端的状态与可恢复，把系统底座补齐：服务边界、错误语义、幂等与重试、审计与可观测、以及 AI 场景下的成本守门。它与用户/计费章节强相关，但这里先讲通用底座，细节在后续章节展开。[22]

## 你将收获什么
- 一套服务边界写法：什么放在同步链路，什么放在异步/后台，什么必须可降级。
- 一套幂等与重试策略：把偶发失败变成可预测事件，而不是线上事故。
- 一套可观测与审计口径：能定位、能复盘、能重放，避免只能祈祷。[6]

## 三层思考：后端要对不可控负责
### 第 1 层：读者目标
你要交付的是一个敢上线的系统：失败可恢复、退化可回滚、成本可解释。

### 第 2 层：论证链条
后端稳定的链条是：

边界清晰 → 契约与错误语义 → 幂等与重试 → 可观测与审计 → 成本与限额 → 灰度与回滚

每一环都是为了把不确定变成可治理。[6]

### 第 3 层：落地与验收
验收不是接口返回 200，而是：
- 失败时用户与系统都知道怎么恢复；
- 关键行为可追溯（谁、何时、对什么、做了什么、结果如何）；
- 成本/延迟越界时系统能自动止损或降级。[6][22]

## 方法论速览：先定边界，再定语义，再定止损
![图 9-1：后端可控底座（边界→语义→幂等→观测→预算→回滚）示意](../../assets/figure_09_1_1765971058740.png)

### 1) 服务边界：把高不确定性隔离出去
AI 相关链路天然波动更大：模型输出、外部工具、网络、数据质量都会引入不确定。建议你先划三条边界：
- **同步链路**：必须在用户等待期间完成的最短路径（越短越好）。
- **异步链路**：可后台执行、可重试、可延迟的工作（导入、索引、训练、报表）。
- **降级路径**：当 AI/外部依赖不可用时，系统如何退一步也能工作。[6]

一个可迁移的最小划分模式是：把同步链路限定为编排与快速校验，把慢与不稳定放进队列与可重试 worker。

```text
HTTP API（鉴权/校验/生成 request_id）
  → Orchestrator（决定走哪条路径：同步/异步/降级）
    → 同步：轻量检索/小模型/缓存命中 → 返回（带 trace_id）
    → 异步：入队 → Worker（索引/重排/长工具链）→ 写入结果 → 前端轮询或回调
    → 降级：只检索不生成/只返回出处/拒答并追问
```

### 2) 契约与错误语义：让失败可行动
错误语义要同时对用户与工程有效：用户知道怎么办，工程知道怎么定位。

如果你想让失败可行动变成可复用的规范，而不是每个接口各写各的口头约定：HTTP 语义与标准化错误载体是很好的底盘。前者决定了能不能安全重试/缓存/代理，后者决定了错误能不能被前端/SDK/Agent 稳定解析并做出正确动作。[78][79]

#### 错误语义表

| 错误码/类型 | 用户看到什么 | 用户能做什么 | 是否可重试 | 是否需要告警 | 备注 |
| --- | --- | --- | --- | --- | --- |
| INVALID_INPUT | 指出具体字段与原因 | 修改后重试 | 否 | 否 | 前端可校验 |
| TIMEOUT | 稍后再试/已为你保留进度 | 重试/查看进度 | 是 | 视阈值 | 需幂等 |
| PERMISSION_DENIED | 无权限 | 申请权限/切换账号 | 否 | 是 | 需审计 |

### 3) 幂等与重试：把重复请求变成默认情况
只要你有网络、有队列、有回调，就会有重复。正确的姿势不是希望它别重复，而是：
- 每个会产生副作用的动作，都有幂等键；
- 每个重试都可解释（为什么重试、重试几次、何时停止）；
- 每个外部回调都可重放（用于对账与复盘）。[5]

#### 幂等设计卡

| 动作 | 副作用 | 幂等键来源 | 重试策略 | 冲突处理 | 证据留档 |
| --- | --- | --- | --- | --- | --- |
| 创建订单 | 写账本/扣费 | order_id | 指数退避 + 上限 | 重复则返回同结果 | 审计事件 |
| 导入数据 | 写入/索引 | import_id | 后台重试 | 支持续传/断点 | 导入报告 |

对 AI 服务调用，幂等的重点不是让模型输出逐字一致，而是避免重复扣费与重复副作用。一个实用做法是：
- 为每次用户动作生成 `action_id`，并在后端把 action_id 绑定到一次模型调用与一次工具链路。
- 重试时优先命中缓存或返回已完成结果，而不是再次调用模型。
- 对工具副作用（发邮件、下单、写库）强制幂等键，禁止模型自己发明 key。

```text
idempotency_key = hash(user_id + action_id + prompt_version + model + normalized_inputs)
if result exists: return result
else: call llm/tools with action_id, record cost, store result, return
```

### 4) 可观测与审计：让系统能解释自己
0→1 阶段不追求指标大全，但必须能定位关键链路。建议你统一三类信号：
- **日志**：结构化字段，能串起一次请求的全路径。
- **指标**：失败率、延迟、吞吐、成本等守门指标。[6]
- **追踪**：至少能关联入口请求 → 关键下游调用。（实现方式可随栈变化）

#### 最小可观测字段规范

| 字段 | 为什么必须 | 例子 |
| --- | --- | --- |
| request_id / trace_id | 串起全链路 | 入口生成并透传 |
| user_id / tenant_id | 定位影响面 | 多租户必备 |
| action | 业务语义 | import.start |
| result | 成功/失败与原因 | success/fail + reason |
| latency_ms | 体验与退化 | P50/P95 |
| cost | AI 场景止损 | token/调用次数/金额 |

对 AI 链路，建议额外补三个字段，让一次线上事故可复盘而不是靠猜：
- model 与 prompt_version：输出从哪套配置来。
- tool_calls：调用了哪些工具与次数（含失败原因）。
- cache_hit：是否命中缓存，避免把缓存命中误判成模型变强。

### 5) 成本守门：把预算写进系统默认值
在 AI 产品里，成本不是财务报表里的事，而是运行时行为。建议你把预算做成三层：
- **单次请求预算**：超过就降级（减少上下文、跳过重排、减少工具调用）。
- **用户/租户预算**：超过就限流或切换到低成本路径。
- **全局预算**：异常尖峰时自动止损，保护现金流。[6]

#### 预算与降级策略

| 预算层级 | 指标 | 阈值 | 越界动作 | 回滚条件 |
| --- | --- | --- | --- | --- |
| 单次请求 | cost/latency | ≤ X | 减少上下文/工具 | 指标恢复 |
| 租户 | 日消耗 | ≤ Y | 限流/提示升级 | 次日重置 |
| 全局 | 峰值消耗 | ≤ Z | 临时关闭高成本功能 | 手动解除 |

把预算落到可执行逻辑，最低只需要一个预算控制器：每一步调用前先检查剩余预算，越界就降级或拒绝。

```text
budget = {max_tokens: N, max_tool_calls: M, max_latency_ms: L}
plan = [retrieve, rerank, generate, tools]
for step in plan:
  if budget exceeded: downgrade(step) or stop_with_reason
  run(step), update budget counters
```

## 关键流程图（纯文本）：一次请求如何可控、可复盘

```text
请求进入 -> 鉴权与租户隔离 -> 参数校验 -> 幂等键与重试策略
  -> 预算检查（单次/租户/全局） -> 执行计划（检索/生成/工具）
    -> 审计事件落盘 -> 统一错误语义返回 -> 指标与告警

门禁（任一缺失视为不可上线）：
- 错误不可行动或不可定位（无 error_code/trace_id）
- 副作用无幂等键或无停止条件
- 预算越界无降级/止损动作
```

## 示例（可复制）：错误语义表 + 幂等键 + 可观测字段合同

**目标：** 让前后端在错误、重试与预算越界上说同一种话，并能用一次 trace_id 复盘一条链路。

**前置条件：**
- 你有一条关键链路（例如导入 → 索引 → 问答）
- 你愿意把错误语义与审计当作产品能力，而不是实现细节

**输出格式：**
- 错误语义表：`docs/backend/error-taxonomy.md`
- 幂等设计卡：`docs/backend/idempotency.md`
- 可观测字段合同：`docs/backend/observability.md`

**步骤：**
1. 写错误语义表：每个错误码必须包含用户可行动的恢复入口与工程可定位字段（error_code、trace_id、retryable）。  
2. 为关键副作用动作写幂等键与停止条件：重复请求必须可重放或可冲正，避免多扣费与数据错乱。[5]  
3. 把预算越界写成默认行为：越界必须降级或停止，并写出 aborted_reason 与回滚动作。[6]

**验证命令：**
```bash
python3 - <<'PY'
from pathlib import Path

err = Path('docs/backend/error-taxonomy.md')
if not err.exists():
  raise SystemExit('missing docs/backend/error-taxonomy.md')

text = err.read_text(encoding='utf-8', errors='replace')
must = ['error_code', 'trace_id', '用户可恢复', '工程可定位']
missing = [k for k in must if k not in text]
if missing:
  raise SystemExit(f'missing fields in error taxonomy: {missing}')

print('ok')
PY
```

**失败判定：**
- 错误发生时只能靠猜（无 trace_id、无错误码、无预算与停止条件）。
- 重试导致副作用重复执行或账单争议无法解释。[5]

**回滚：**
- 回到上一稳定错误语义与预算策略；把触发样本写入回归集，直到复跑通过再继续迭代。[6]

## 复现检查清单（本章最低门槛）
- 错误语义表已落地并一致遵守：用户可行动、工程可定位、机器可解析；含错误码、恢复入口与告警口径。
- 幂等与重试可复跑：关键副作用动作都有幂等键、重试上限、停止条件与冲正/回滚路径。[5]
- 一次请求可复盘：最小可观测字段齐全，能用一次 request_id/trace_id 串起关键链路与成本归因。[6]
- 成本守门可执行：预算越界时有明确降级/止损动作，并记录原因与版本组合。[6]

## 常见陷阱（失败样本）
1. **现象：** 线上偶发错误难定位，只能靠猜。  
   **根因：** 缺 trace_id/request_id、缺关键字段、缺统一错误语义，导致复盘链路断裂。[6]  
   **复现：** 同一类错误在日志里无法串起请求、上游依赖与预算消耗，只能看零散报错。  
   **修复：** 先统一错误语义与观测字段，再优化性能；把可观测当作功能的一部分。[6]  
   **回归验证：** 任意一次失败都能用 trace_id 串起关键耗时、成本与错误原因；同类错误能聚合成报表与告警。[6]

2. **现象：** 接口偶尔重复执行，导致数据错乱或多扣费。  
   **根因：** 把重复请求当异常，而不是默认；副作用缺幂等键与冲正路径。[5]  
   **复现：** 重试、超时与 webhook 重放导致同一动作被执行多次，账本与业务状态不一致。  
   **修复：** 幂等键 + 可重放审计 + 冲正机制；重复请求视为同一请求返回同结果。[5]  
   **回归验证：** 重放同一请求只产生一次副作用；对账能复现并解释每笔变动来源。[5]

3. **现象：** AI 功能上线后成本不可控。  
   **根因：** 没有预算与降级路径；把更聪明当成无上限，异常输入触发循环与重试风暴。[6]  
   **复现：** 长输入、弱网或工具失败时触发多轮调用，token 成本与延迟迅速放大。  
   **修复：** 把预算写进运行时；越界即降级/限流/关闭高成本功能，并记录 aborted_reason。[6]  
   **回归验证：** 预算越界样本进入回归集；门禁能稳定拦截并触发降级，线上成本曲线不再尖峰。[6]

## 交付物清单与验收标准
- 服务边界说明（同步/异步/降级）。
- 错误语义表（用户可行动 + 工程可定位）。
- 幂等设计卡（关键副作用动作至少 3 条）。[5]
- 可观测字段规范与守门指标阈值（含成本/延迟）。[6]

## 下一章
当后端底座可控，你可以开始引入智能层：让回答带证据、让行动有边界、让改动可回归。下一章见：[10-agent-rag.md](10-agent-rag.md)。

## 参考
详见本书统一参考文献列表：[references.md](references.md)。
