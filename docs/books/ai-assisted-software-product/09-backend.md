# 第 9 章：后端架构：边界、幂等与可观测
![第 9 章封面](../../assets/chapter_09_header_1766035625708.png)

> 后端不是把接口跑通，而是把风险关在笼子里：错误语义一致、请求可重放、成本可止损、事故可追责。[5][6]

0→1 的后端常见两种失败：一种是能跑但不稳，另一种是稳但太贵。AI 让第二种更常见：一次看似无害的改动，可能把调用次数、上下文长度或工具链路放大，成本与延迟像潮水一样淹没你。[6]

## 章节定位
本章承接前端的状态与可恢复，把系统底座补齐：服务边界、错误语义、幂等与重试、审计与可观测、以及 AI 场景下的成本守门。它与用户/计费章节强相关，但这里先讲通用底座，细节在后续章节展开。[22]

## 你将收获什么
- 一套服务边界写法：什么放在同步链路，什么放在异步/后台，什么必须可降级。
- 一套幂等与重试策略：把偶发失败变成可预测事件，而不是线上事故。
- 一套可观测与审计口径：能定位、能复盘、能重放，避免只能祈祷。[6]

## 三层思考：后端要对不可控负责
### 第 1 层：读者目标
你要交付的是一个敢上线的系统：失败可恢复、退化可回滚、成本可解释。

### 第 2 层：论证链条
后端稳定的链条是：

边界清晰 → 契约与错误语义 → 幂等与重试 → 可观测与审计 → 成本与限额 → 灰度与回滚

每一环都是为了把不确定变成可治理。[6]

### 第 3 层：落地与验收
验收不是接口返回 200，而是：
- 失败时用户与系统都知道怎么恢复；
- 关键行为可追溯（谁、何时、对什么、做了什么、结果如何）；
- 成本/延迟越界时系统能自动止损或降级。[6][22]

## 方法论速览：先定边界，再定语义，再定止损
![图 9-1：后端可控底座（边界→语义→幂等→观测→预算→回滚）示意](../../assets/figure_09_1_1765971058740.png)

### 1) 服务边界：把高不确定性隔离出去
AI 相关链路天然波动更大：模型输出、外部工具、网络、数据质量都会引入不确定。建议你先划三条边界：
- **同步链路**：必须在用户等待期间完成的最短路径（越短越好）。
- **异步链路**：可后台执行、可重试、可延迟的工作（导入、索引、训练、报表）。
- **降级路径**：当 AI/外部依赖不可用时，系统如何退一步也能工作。[6]

一个可迁移的最小划分模式是：把同步链路限定为编排与快速校验，把慢与不稳定放进队列与可重试 worker。

```text
HTTP API（鉴权/校验/生成 request_id）
  → Orchestrator（决定走哪条路径：同步/异步/降级）
    → 同步：轻量检索/小模型/缓存命中 → 返回（带 trace_id）
    → 异步：入队 → Worker（索引/重排/长工具链）→ 写入结果 → 前端轮询或回调
    → 降级：只检索不生成/只返回出处/拒答并追问
```

### 2) 契约与错误语义：让失败可行动
错误语义要同时对用户与工程有效：用户知道怎么办，工程知道怎么定位。

如果你想让失败可行动变成可复用的规范，而不是每个接口各写各的口头约定：HTTP 语义与标准化错误载体是很好的底盘。前者决定了能不能安全重试/缓存/代理，后者决定了错误能不能被前端/SDK/Agent 稳定解析并做出正确动作。[78][79]

#### 错误语义表

| 错误码/类型 | 用户看到什么 | 用户能做什么 | 是否可重试 | 是否需要告警 | 备注 |
| --- | --- | --- | --- | --- | --- |
| INVALID_INPUT | 指出具体字段与原因 | 修改后重试 | 否 | 否 | 前端可校验 |
| TIMEOUT | 稍后再试/已为你保留进度 | 重试/查看进度 | 是 | 视阈值 | 需幂等 |
| PERMISSION_DENIED | 无权限 | 申请权限/切换账号 | 否 | 是 | 需审计 |

### 3) 幂等与重试：把重复请求变成默认情况
只要你有网络、有队列、有回调，就会有重复。正确的姿势不是希望它别重复，而是：
- 每个会产生副作用的动作，都有幂等键；
- 每个重试都可解释（为什么重试、重试几次、何时停止）；
- 每个外部回调都可重放（用于对账与复盘）。[5]

#### 幂等设计卡

| 动作 | 副作用 | 幂等键来源 | 重试策略 | 冲突处理 | 证据留档 |
| --- | --- | --- | --- | --- | --- |
| 创建订单 | 写账本/扣费 | order_id | 指数退避 + 上限 | 重复则返回同结果 | 审计事件 |
| 导入数据 | 写入/索引 | import_id | 后台重试 | 支持续传/断点 | 导入报告 |

对 AI 服务调用，幂等的重点不是让模型输出逐字一致，而是避免重复扣费与重复副作用。一个实用做法是：
- 为每次用户动作生成 `action_id`，并在后端把 action_id 绑定到一次模型调用与一次工具链路。
- 重试时优先命中缓存或返回已完成结果，而不是再次调用模型。
- 对工具副作用（发邮件、下单、写库）强制幂等键，禁止模型自己发明 key。

```text
idempotency_key = hash(user_id + action_id + prompt_version + model + normalized_inputs)
if result exists: return result
else: call llm/tools with action_id, record cost, store result, return
```

### 4) 可观测与审计：让系统能解释自己
0→1 阶段不追求指标大全，但必须能定位关键链路。建议你统一三类信号：
- **日志**：结构化字段，能串起一次请求的全路径。
- **指标**：失败率、延迟、吞吐、成本等守门指标。[6]
- **追踪**：至少能关联入口请求 → 关键下游调用。（实现方式可随栈变化）

#### 最小可观测字段规范

| 字段 | 为什么必须 | 例子 |
| --- | --- | --- |
| request_id / trace_id | 串起全链路 | 入口生成并透传 |
| user_id / tenant_id | 定位影响面 | 多租户必备 |
| action | 业务语义 | import.start |
| result | 成功/失败与原因 | success/fail + reason |
| latency_ms | 体验与退化 | P50/P95 |
| cost | AI 场景止损 | token/调用次数/金额 |

对 AI 链路，建议额外补三个字段，让一次线上事故可复盘而不是靠猜：
- model 与 prompt_version：输出从哪套配置来。
- tool_calls：调用了哪些工具与次数（含失败原因）。
- cache_hit：是否命中缓存，避免把缓存命中误判成模型变强。

#### 版本集合（version_set）与标签口径：拒绝“差不多”
如果你的监控面板不带 `version_set`，你看到的就是混合平均值：新旧版本、不同入口、不同输入长度、不同租户被搅在一起，最后你只能在事故发生后“凭感觉回滚”。这不是可观测性，这是祈祷。

- **告警与面板必须按 `version_set` 对齐口径**：否则你无法回答“这次发布让哪个版本变好/变坏”。指标字典与统一标签规范见：[F-metrics-alerts.md](F-metrics-alerts.md)。
- **证据包目录必须固定**：每次变更把日志/指标/对比表归档到 `reports/YYYY-MM-DD/<change-id>/`，否则告警响了也找不到证据。结构模板见：[D-evidence-pack.md](D-evidence-pack.md)。

| 字段 | 用途 | 示例值 | 常见误区 |
| --- | --- | --- | --- |
| `version_set` | 唯一确定本次行为来自哪套组合（代码/配置/模型/提示/索引/策略） | `code=a1b2c3 cfg=sha256:... model=v3 prompt=p12 index=i7 policy=r9` | 只记 git commit；提示词/索引/策略变了却查不出来 |
| `request_id` | 用户侧可追踪（客服/工单/导出明细） | `req-abc-123` | 只在网关有，后端/worker 不透传 |
| `trace_id` | 工程侧可串起全链路（网关→服务→工具→回调） | `trace-def-456` | 有 trace 但缺关键 span 属性，还是定位不了 |
| `tenant_id` | 定位影响面与隔离归因 | `t-001` | 只在业务库里有，监控侧丢失 |
| `actor_id` | 审计与追责（谁触发） | `u-123` | 只记录“匿名”，出事无法解释 |
| `action` | 业务语义（可聚合统计） | `chat.complete` / `kb.ingest` | 只写 URL 路径，语义不可读 |
| `model_version` | 模型升级/回滚归因 | `model=v3` | 同一指标混多个模型版本 |
| `prompt_version` | prompt 漂移归因 | `prompt=p12` | prompt 变更不留痕，只能靠猜 |
| `index_version` | RAG 索引/语料回滚归因 | `index=i7` | 只记录 index alias，不记录具体版本 |
| `policy_version` | 安全策略/拒答口径归因 | `policy=r9` | 策略误伤/漏拦截无法追溯到版本 |
| `aborted_reason` | 记录“为什么没做完”（预算/安全/依赖） | `budget_exceeded` / `policy_blocked` | 把熔断/拒答记为成功或未知错误 |

| Label | 必选 | 示例 | 为什么 |
| --- | --- | --- | --- |
| `env` | 是 | `prod` | 生产与灰度口径必须隔离 |
| `entrypoint` | 是 | `web` / `api` / `batch` | batch 的慢不该淹没 web 的慢 |
| `input_len_bucket` | 是 | `<1k` / `1k-4k` / `4k-16k` / `>16k` | 不分桶会把长输入的尾延迟误判成整体退化 |
| `version_set` | 是 | `code=a1b2c3+prompt=p12+model=v3` | 不带版本指纹就无法判断“这次发布变好了吗” |
| `tenant_id` | 是（多租户） | `t-001` | 单一租户爆炸会被全局平均掩盖 |
| `model_version` | 强烈建议 | `v3` | 模型升级的收益/代价必须可对比 |
| `prompt_version` | 强烈建议 | `p12` | prompt 漂移是最常见的隐性回归源 |
| `index_version` | 强烈建议（RAG） | `i7` | 索引/语料变化必须能一键回滚 |
| `policy_version` | 强烈建议 | `r9` | 安全策略拦截率上升要能归因 |
| `tool_name` | 工具链路有用 | `search` / `payment` | 工具失败/慢会放大端到端尾延迟 |

```text
请求进入
  → 结构化日志（带 version_set + trace_id）
  → 指标聚合（按 env/entrypoint/input_len_bucket/version_set 分桶）
  → 证据包落盘（reports/YYYY-MM-DD/<change-id>/）
  → 告警触发（阈值三段式：基线分位数 + 倍数 + 绝对红线）
  → 执行动作（降级/回滚，绑定 Runbook）
```

```text
# 示例 1：一行结构化日志（让每条日志都能归因到版本与租户）
ts=2025-12-23T22:10:00Z request_id=req-abc-123 trace_id=trace-def-456 tenant_id=t-001 actor_id=u-123 action=chat.complete result=success latency_ms=1250 tokens_in=500 tokens_out=120 tool_calls=search:1 cache_hit=false cost_usd=0.002 version_set='code=a1b2c3 cfg=sha256:... model=v3 prompt=p12 index=i7 policy=r9'
```

```yaml
# 示例 2：告警规则（阈值三段式：基线分位数 + 倍数 + 绝对红线）
alert: alert.latency_spike
metric: latency.ttft_ms
window: 5m
bucket_by: [entrypoint, input_len_bucket, version_set]
baseline:
  source: rolling_7d_p99
warn:
  when: current_p99 > baseline_p99 * 1.5
  action: "暂停扩量，进入 RB-03（见 E-runbooks.md）"
block:
  when: current_p99 > 3000 # 绝对红线示例：3s
  action: "立即降级/回滚，进入 RB-03（见 E-runbooks.md）"
evidence_dir: reports/YYYY-MM-DD/<change-id>/ # 参照 D-evidence-pack.md
```

### 5) 成本守门：把预算写进系统默认值
在 AI 产品里，成本不是财务报表里的事，而是运行时行为。建议你把预算做成三层：
- **单次请求预算**：超过就降级（减少上下文、跳过重排、减少工具调用）。
- **用户/租户预算**：超过就限流或切换到低成本路径。
- **全局预算**：异常尖峰时自动止损，保护现金流。[6]

#### 预算与降级策略

| 预算层级 | 指标 | 阈值 | 越界动作 | 回滚条件 |
| --- | --- | --- | --- | --- |
| 单次请求 | cost/latency | ≤ X | 减少上下文/工具 | 指标恢复 |
| 租户 | 日消耗 | ≤ Y | 限流/提示升级 | 次日重置 |
| 全局 | 峰值消耗 | ≤ Z | 临时关闭高成本功能 | 手动解除 |

把预算落到可执行逻辑，最低只需要一个预算控制器：每一步调用前先检查剩余预算，越界就降级或拒绝。

```text
budget = {max_tokens: N, max_tool_calls: M, max_latency_ms: L}
plan = [retrieve, rerank, generate, tools]
for step in plan:
  if budget exceeded: downgrade(step) or stop_with_reason
  run(step), update budget counters
```

## 关键流程图（纯文本）：一次请求如何可控、可复盘

```text
请求进入 -> 鉴权与租户隔离 -> 参数校验 -> 幂等键与重试策略
  -> 预算检查（单次/租户/全局） -> 执行计划（检索/生成/工具）
    -> 审计事件落盘 -> 统一错误语义返回 -> 指标与告警

门禁（任一缺失视为不可上线）：
- 错误不可行动或不可定位（无 error_code/trace_id）
- 副作用无幂等键或无停止条件
- 预算越界无降级/止损动作
```

## 示例（可复制）：错误语义表 + 幂等键 + 可观测字段合同

**目标：** 让前后端在错误、重试与预算越界上说同一种话，并能用一次 trace_id 复盘一条链路。

**前置条件：**
- 你有一条关键链路（例如导入 → 索引 → 问答）
- 你愿意把错误语义与审计当作产品能力，而不是实现细节

**输出格式：**
- 错误语义表：`docs/backend/error-taxonomy.md`
- 幂等设计卡：`docs/backend/idempotency.md`
- 可观测字段合同：`docs/backend/observability.md`

**步骤：**
1. 写错误语义表：每个错误码必须包含用户可行动的恢复入口与工程可定位字段（error_code、trace_id、retryable）。  
2. 为关键副作用动作写幂等键与停止条件：重复请求必须可重放或可冲正，避免多扣费与数据错乱。[5]  
3. 把预算越界写成默认行为：越界必须降级或停止，并写出 aborted_reason 与回滚动作。[6]

**验证命令：**
```bash
python3 - <<'PY'
from pathlib import Path

err = Path('docs/backend/error-taxonomy.md')
if not err.exists():
  raise SystemExit('missing docs/backend/error-taxonomy.md')

text = err.read_text(encoding='utf-8', errors='replace')
must = ['error_code', 'trace_id', '用户可恢复', '工程可定位']
missing = [k for k in must if k not in text]
if missing:
  raise SystemExit(f'missing fields in error taxonomy: {missing}')

print('ok')
PY
```

**失败判定：**
- 错误发生时只能靠猜（无 trace_id、无错误码、无预算与停止条件）。
- 重试导致副作用重复执行或账单争议无法解释。[5]

**回滚：**
- 回到上一稳定错误语义与预算策略；把触发样本写入回归集，直到复跑通过再继续迭代。[6]

## 复现检查清单（本章最低门槛）
- 错误语义表已落地并一致遵守：用户可行动、工程可定位、机器可解析；含错误码、恢复入口与告警口径。
- 幂等与重试可复跑：关键副作用动作都有幂等键、重试上限、停止条件与冲正/回滚路径。[5]
- 一次请求可复盘：最小可观测字段齐全，能用一次 request_id/trace_id 串起关键链路与成本归因。[6]
- 成本守门可执行：预算越界时有明确降级/止损动作，并记录原因与版本组合。[6]

## 常见陷阱（失败样本）
1. **现象：** 线上偶发错误难定位，只能靠猜。  
   **根因：** 缺 trace_id/request_id、缺关键字段、缺统一错误语义，导致复盘链路断裂。[6]  
   **复现：** 同一类错误在日志里无法串起请求、上游依赖与预算消耗，只能看零散报错。  
   **修复：** 先统一错误语义与观测字段，再优化性能；把可观测当作功能的一部分。[6]  
   **回归验证：** 任意一次失败都能用 trace_id 串起关键耗时、成本与错误原因；同类错误能聚合成报表与告警。[6]

2. **现象：** 接口偶尔重复执行，导致数据错乱或多扣费。  
   **根因：** 把重复请求当异常，而不是默认；副作用缺幂等键与冲正路径。[5]  
   **复现：** 重试、超时与 webhook 重放导致同一动作被执行多次，账本与业务状态不一致。  
   **修复：** 幂等键 + 可重放审计 + 冲正机制；重复请求视为同一请求返回同结果。[5]  
   **回归验证：** 重放同一请求只产生一次副作用；对账能复现并解释每笔变动来源。[5]

3. **现象：** AI 功能上线后成本不可控。  
   **根因：** 没有预算与降级路径；把更聪明当成无上限，异常输入触发循环与重试风暴。[6]  
   **复现：** 长输入、弱网或工具失败时触发多轮调用，token 成本与延迟迅速放大。  
   **修复：** 把预算写进运行时；越界即降级/限流/关闭高成本功能，并记录 aborted_reason。[6]  
   **回归验证：** 预算越界样本进入回归集；门禁能稳定拦截并触发降级，线上成本曲线不再尖峰。[6]

## 交付物清单与验收标准
- 服务边界说明（同步/异步/降级）。
- 错误语义表（用户可行动 + 工程可定位）。
- 幂等设计卡（关键副作用动作至少 3 条）。[5]
- 可观测字段规范与守门指标阈值（含成本/延迟）。[6]

## 下一章
当后端底座可控，你可以开始引入智能层：让回答带证据、让行动有边界、让改动可回归。下一章见：[10-agent-rag.md](10-agent-rag.md)。

## 参考
详见本书统一参考文献列表：[references.md](references.md)。
