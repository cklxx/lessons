# 第 6 章：UI 设计：把体验做成可维护资产
![Chapter 6 Header](../../assets/chapter_06_header_1766035568708.png)

> 好看不难，难的是既好用，又经得起迭代。在 0→1 阶段，UI 的第一任务不是装饰，而是把不确定性压缩：让用户知道下一步是什么、失败后怎么回来、并且每次改动都能回归。[17]

如果你已经在上一章证明闭环成立，接下来最常见的失速来自两件事：一是体验不稳定（入口绕、状态缺、错误不可恢复），二是迭代成本越来越高（每次改 UI 都像重新装修）。本章要做的，就是把体验沉淀成资产：规格、组件、可访问性与回归基线。

## 章节定位
本章位于验证与打磨之后、工程化之前。它的目标不是教你画得更漂亮，而是教你把 UI 变成可维护系统：能复用、能解释、能回归、能适应下一轮迭代。[17]

## 你将收获什么
- 一套文字规格优先的写法：先把任务、信息层级、状态与恢复写清楚，再谈视觉。
- 一份最小可访问性（a11y）验收清单：把可用变成发布门槛，而不是上线后的补丁。[17]
- 一套把界面沉淀为资产的方法：组件与变体、状态基线、文案规范、边界与例外。

## 三层思考：UI 设计的本质是降低认知与维护成本
### 第 1 层：读者目标
读完本章，你应该能输出可实现、可验收、可回归的 UI 规格，让任何一次改动都能回答：
- 它改善了哪个断点？
- 它是否引入了新的失败？
- 它是否会在下轮迭代中继续可维护？

### 第 2 层：论证链条
UI 从灵感到可维护资产的链条是：

任务与信息层级 → 状态与错误恢复 → 组件与变体 → 文案与一致性 → 可访问性门槛 → 回归基线

缺其中任一环，UI 会变成截图工程：能看不能用，能用不稳定，能稳定但难维护。[17]

### 第 3 层：落地与验收
UI 的验收不止是视觉对齐，更要包含：
- 关键任务是否更短、更清晰、更可预测；
- 关键状态是否齐全（空/加载/成功/失败/无权限）；
- 键盘与辅助技术是否可用（最低门槛）；
- 文案与布局在真实约束下是否成立（长文案、移动端、弱网）。[17]

## 方法论速览：先写规格，再做风格，再沉淀组件
![图 6-1：UI 资产化链路（文字规格→组件→a11y→回归）示意（占位）](../../assets/figure_06_1_1765970946243.png)

### 1) 先写文字规格（让争论有裁判）
所谓文字规格，不是写一篇文案，而是写清楚：
- 这个页面的目标是什么（为哪个用例服务）；
- 用户的下一步是什么（主 CTA 是什么）；
- 失败后怎么回来（错误恢复入口在哪里）；
- 每个关键状态如何呈现（空/加载/失败/无权限）。[17]

**模板：页面文字规格（最小可验收）**

| 模块 | 你要写什么 |
| --- | --- |
| 页面目标 | 一句话：用户来这里要完成什么 |
| 主 CTA | 一句话：点击后发生什么；失败如何提示 |
| 信息层级 | 3 层以内：主信息/次信息/辅助信息 |
| 状态清单 | 空/加载/成功/失败/无权限（每个状态的文案与入口） |
| 错误恢复 | 重试/返回/求助/联系客服/查看示例（至少 1 个） |
| 约束 | 设备/网络/权限/数据规模（影响交互与文案） |
| 验收 | 任务完成率、耗时、错误恢复率（同口径） |

### 2) 再谈风格（风格服务于信息层级）
风格不是不要，而是要服从信息层级：颜色、字号、间距、对比度、动效都应当强化下一步是什么。如果风格掩盖了下一步，说明你在用美观掩盖结构问题。

### 3) 把组件当成长期资产
0→1 时你不需要完整设计系统，但需要一个不会失控的最小集合：
- 基础组件：按钮、表单、对话框、列表、提示、空状态、加载骨架。
- 规则优先：每个组件都要写清楚变体与状态；业务页面尽量组合组件，不复制样式。

**模板：组件规格（变体与状态）**

| 组件 | 变体 | 状态（必须覆盖） | 交互与反馈 | 禁止项 |
| --- | --- | --- | --- | --- |
| Button | primary/secondary/danger | 默认/禁用/加载 | 键盘可触达；加载时不可重复提交 | 在页面内自定义一套新按钮 |
| Input | text/password | 默认/聚焦/错误/只读 | 错误提示可理解且可恢复 | 仅用占位符代替标签 |

## Design Tokens：把风格变成可执行约束
当你开始频繁迭代 UI，一致性会成为最大的隐性成本：颜色、间距、阴影、圆角到处散落（Figma、CSS、组件里各一份），AI 生成的代码更容易出现看起来差不多但不一致的幻觉。解决思路是把设计决策写成一个可版本化、可生成、可校验的**唯一事实源**：Design Tokens。[53]

![图 6-2：Design Tokens 出码与门禁闭环](../../assets/figure_06_2_tokens_pipeline.svg)

如果你做过一次全站换主色，你会发现真正折磨人的不是改一个值，而是：

- 你不知道哪里还藏着硬编码的 `#3b82f6`；
- 你不知道哪些页面会被影响、影响是否可接受；
- 你不知道改完以后有没有退化（对比度、可访问性、视觉一致性）。

Design Tokens 的意义就是把这些不确定性压缩成**可审查的变更**：你改的是一份 JSON，所有产物由出码生成；你的门禁跑的是 a11y/质量回归，而不是靠肉眼扫页面。[53]

你可以把 Token 当成UI 的配置与契约：
- **基础层（Primitive）**：原始值（如 `blue-500`）。
- **语义层（Semantic）**：表达意图（如 `color.action.primary`），尽量不要把长什么样写进名字。[53]
- **组件层（Component）**：把语义绑定到组件状态（如 `button.bg.default`）。[53]

**模板：最小 Token 规范（可直接起步）**

| 要素 | 约定 |
| --- | --- |
| 存储格式 | 用 JSON 作为唯一事实源（可被工具链消费/生成）[53] |
| 命名 | 语义化（error-bg）优先于外观化（red-bg）[53] |
| 引用 | 组件层尽量只引用语义层；减少魔法值[53] |
| 出码 | 用工具（如 Style Dictionary）从同一份 Token 生成多端产物（CSS Variables / iOS / Android）[53] |
| 回归 | Token 变更必须触发视觉回归或关键页面走查，避免一处改动全站变脸[53] |

把 Token 作为约束层后，AI 的使用方式也会变：你不需要让 AI 设计颜色，而是让它在给定 Token 的边界内组合 UI。最直接的规则是：**生成代码时禁止写十六进制颜色，只能引用 Token 键名**。[53]

### 能跑的最小示例：Tokens JSON → CSS Variables（Python）
为了让你把 Token 真正落地，而不是停留在概念里，这里给一个零依赖、能跑起来的出码示例：

- Token 示例：`docs/examples/ui/tokens.sample.json`
- 出码脚本：`docs/examples/ui/design_tokens_to_css.py`

运行：

```bash
python3 docs/examples/ui/design_tokens_to_css.py \
  --in docs/examples/ui/tokens.sample.json \
  --out docs/assets/generated/tokens.sample.css
```

你会得到一份可直接引入的 CSS Variables（同时把 `{color.blue.600}` 这类别名转成 `var(--color-blue-600)`），这样语义层/组件层引用才能真正进入你的工程与回归体系。

## 可访问性（a11y）：把可用变成发布门槛
可访问性不是照顾少数人，而是让产品在真实世界更稳：键盘用户、弱网、老旧设备、不同语言长度，都会逼你把交互做扎实。[17]

**最小 a11y 验收清单（建议作为门槛）**
- 键盘可完成关键任务（Tab 顺序、Enter 提交、Esc 关闭）。
- 焦点可见且顺序合理（不会迷失焦点）。
- 文本对比度达标（主信息与 CTA 清晰）。
- 表单有明确标签与错误提示（错误提示可理解且可恢复）。
- 动效可克制（不靠动效传递关键信息；允许减少动效）。

### 从 WCAG 2.2 到可自动化的门禁
如果你只记住一件事：把可访问性从上线后修改成合入前拦。WCAG 2.2 的优势在于它把体验变成可验收条目（例如焦点可见、点击目标尺寸）。[17]

**补强：WCAG 2.2 AA 的几个高杠杆点**
- **焦点可见且不被遮挡**：Sticky Header/Footer 不能把聚焦元素盖住。[17]
- **点击目标尺寸**：移动端触控目标至少 24×24 CSS 像素（或提供足够间距）。[17]
- **语义化优先**：能用原生 `<button>` 就别用 `<div onClick>` 再用 ARIA 修补。[17]

### axe-core：把 a11y 退化拦在 CI 里
自动化工具覆盖不了全部 WCAG，但它非常适合做底线守门员：防止已修复的低级错误反复出现。[54]

**最小集成策略（从易到难）**
1. 组件单测：`jest-axe` / `vitest-axe` 扫描基础组件（Button/Input/Dialog）。[54]
2. E2E：在 Playwright/Cypress 中注入 `axe.run()`，只在关键状态变化后跑（弹窗打开、表单报错、路由切换）。[54]
3. CI 阻断：对 `critical/serious` 级别违规零容忍；老项目用基线策略先守新增。 [54]

## 质量门禁：用 Lighthouse 把感觉变成分数
UI 体验的另一个大坑是看起来没问题，但实际很慢/很脆。Lighthouse 能把性能、a11y、最佳实践这类主观判断变成可追踪的分数与建议，非常适合放进流水线做门禁。[55]

**建议的最小门槛（按项目调参）**
- 新页面：Performance ≥ 80（移动端口径），Accessibility ≥ 100。[55]
- 规则化：用 Lighthouse CI（LHCI）在 CI 中断言阈值，退化即阻断。[55]

## 回归策略：组件先行，E2E 兜底
当你开始资产化组件库，最划算的回归顺序通常是：**组件级回归跑得勤，页面级 E2E 只守黄金链路**。[56][57]

### Storybook Test Runner：把 Story 变成测试用例
如果你已经在写 Story 展示组件的各种状态，Test Runner 可以把它们直接转成可在 CI 里跑的冒烟/交互回归，并且在真实浏览器中执行（基于 Playwright）。[56]

**组件级回归的最低门槛**
- 每个关键组件至少 1 个 Story 覆盖成功/失败状态；表单/弹窗类组件用 `play` 覆盖一次交互。[56]
- 对网络请求组件用 MSW Mock，避免测试依赖后端与环境波动。[56]
- 可访问性顺手做：在 Story 执行后跑一次 a11y 扫描，作为 DoD。[56][54]

### Playwright：黄金链路的最后一道门禁
E2E 不该覆盖一切，它应该只守不能出错的那几条路：注册、登录、支付、关键配置等。[57]

**黄金链路 E2E 的写法（更稳、更省维护）**
- 选择器优先用 `getByRole/getByText`（面向用户可见属性），避免脆弱的 class/XPath。[57]
- 测试独立：每条用例都在全新浏览器上下文中运行，避免 Cookie/LocalStorage 污染。[57]
- 失败可复盘：保留 Trace，CI 失败时直接用 Trace Viewer 定位，无需本地复现。[57]

## 多语言与多端：把真实约束提前
0→1 最容易的爆雷是：只在理想文案与理想屏幕下成立。

**最小检查清单（i18n/多端）**
- 长文案不溢出、不遮挡 CTA（至少准备一组超长文案样例）。
- 移动端关键任务不需要精确点击（避免小按钮挤在一起）。
- 弱网/慢设备下加载态与重试入口明确。

## AI 怎么用在 UI 上（但不替你做判断）
把 AI 放在生成备选与做一致性检查上：
- 生成 3 版文案与引导，要求每版都说明对应哪类失败断点；
- 让 AI 做一致性巡检：术语是否统一、按钮动词是否一致、错误提示是否可恢复；
- 让 AI 按清单检查 a11y 风险点，输出可直接改写的一句话而不是泛泛建议。[17]

## 复现检查清单（本章最低门槛）
- 每个关键页面都有文字规格 + 状态清单 + 恢复入口，缺一项视为未完成。[17]
- 至少一轮任务走查：用户在无指导情况下能完成关键任务；失败能自救。
- a11y 最小门槛满足：键盘可达、焦点可见、错误可恢复。[17]

## 常见陷阱（失败样本）
1. **现象**：界面精美，但用户找不到关键操作。  
   **根因**：视觉装饰压过信息层级；缺少下一步是什么的明确表达。  
   **修复**：回到文字规格，先改信息层级与入口，再改样式。

2. **现象**：每次迭代 UI 都越改越乱、组件逐渐分裂。  
   **根因**：没有最小组件集合的单一来源；业务页面随手复制样式。  
   **修复**：把基础组件与变体写成规则；新增样式必须通过复用与一致性审查。

3. **现象**：上线后才发现加载慢、错误多、用户无法恢复。  
   **根因**：只在成功路径下设计；把失败当工程实现细节。  
   **修复**：把失败与恢复入口写进规格与组件状态，作为验收门槛。[17]

## 交付物清单与验收标准
- 页面文字规格（关键页面至少 3 个）。
- 组件规格（基础组件最小集合）与一致性规则。
- a11y 与多端检查记录（至少覆盖关键任务）。
- Token 资产与出码链路（最小三层 Token + 出码 + 回归门禁）。[53]
- UI 自动化门禁：axe-core / Lighthouse / 组件级回归 / 黄金链路 E2E 至少各 1 条跑通。[54][55][56][57]

## 下一章
当你把体验做成可维护资产，下一步是把 AI 纳入交付系统：让每次改动都能被验证、被审查、被回滚。下一章见：[`07-engineering.md`](07-engineering.md)。

## 参考
详见本书统一参考文献列表：[`references.md`](references.md)。
