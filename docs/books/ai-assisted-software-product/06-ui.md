# 第 6 章：UI 设计：把体验做成可维护资产

![第 6 章封面](../../assets/chapter_06_header_1766035568708.png)
> **Image Prompt:** A clean, architectural blueprint style illustration showing a UI component breaking down into layers: wireframe, design tokens (hex codes converting to semantic names), and accessibility tags. Background is dark technical blue. No text.
> **Params:** --ar 16:9 --v 6.0 --style raw

好看不难，难的是经得起折腾。在 0 到 1 阶段，UI 的第一任务不是“惊艳”，而是**收敛不确定性**。让用户闭着眼都知道下一步点哪，让开发者哪怕把代码删了一半还能跑通主流程。

如果你上一章的验证闭环已经跑通，接下来的最大风险就是“UI 腐烂”：入口越藏越深，状态越补越乱，每次改个颜色都要改十几个文件。本章不教配色，只教你如何把 UI 从“画图”变成“资产”：一套能复用、能自动回归、能让 AI 帮你维护的工程系统。

## 章节定位
本章位于验证之后、大规模工程化之前。它的目标是建立一套**UI 资产化流水线**，确保你的界面在快速迭代中不会因为“欠债太多”而崩塌。

## 你的交付物
读完本章，你必须能拿出以下资产，而不是几张 Figma 截图：
1.  **文字规格（Text Spec）**：在画图前，先定义任务流、信息层级和异常出口。
2.  **状态矩阵（State Matrix）**：不仅有成功态，还有空、加载、失败、无权限和流式传输态。
3.  **Design Tokens**：把颜色和间距变成 JSON 约束，而不是散落在 CSS 里的魔法值。
4.  **A11y 门禁**：把可访问性（Accessibility）变成 CI 里的红绿灯，而不是上线后的补丁。

## 核心逻辑：UI 的本质是降低认知与维护成本

### 1. 为什么先写文字规格？
因为 Figma 画得越快，逻辑漏洞埋得越深。在像素级设计之前，你必须先用文字“拷问”你的界面。

**UI 必须回答的三个问题：**
1.  **下一步是什么？**（主行动按钮明确吗？）
2.  **失败了怎么办？**（有重试、回退或人工介入入口吗？）
3.  **我在哪？**（导航和状态反馈清晰吗？）

### 2. UI 资产化链路
从灵感到代码，必须经过这层过滤，否则就是给未来埋雷。

![图 6-1：UI 资产化链路](../../assets/figure_06_1_1765970946243.png)
> **Image Prompt:** A flowchart diagram showing the transformation of UI assets. Left side: "Raw Idea" (chaotic cloud). Middle: "Constraints" (filter funnel labeled Spec, Tokens, A11y). Right: "Asset" (neatly stacked blocks). Clean lines, minimal color. No text in base image.

## 步骤一：文字规格与状态矩阵

别让 AI 直接生成界面，它会给你堆砌一堆看起来很美但没法用的占位符。你得先给它“骨架”。

### 模板 1：关键页面文字规格
把这个表格填好，比画 10 张草图都管用。

| 维度 | 必须定义的内容 | 验收标准（门槛） |
| :--- | :--- | :--- |
| **页面目标** | 用户来这只为了做哪**一件事**？ | 删掉其他所有元素，这事还能做成吗？ |
| **主 CTA** | 点击后发生什么？是跳转、提交还是展开？ | 屏幕眯着眼看，它是最显眼的吗？ |
| **信息层级** | 谁是主角（H1）？谁是配角（H2）？谁是噪音？ | 第一眼只能看到 3 个以内的重点。 |
| **错误恢复** | 如果接口挂了/没权限/数据错了，用户能干嘛？ | 必须提供至少一个动作：重试、返回、联系支持。 |

### 模板 2：全状态矩阵（State Matrix）
只画成功态是掩耳盗铃。对 AI 产品，流式状态更是重灾区。

| 状态 | 描述 | 必备元素 |
| :--- | :--- | :--- |
| **Empty (空)** | 还没数据，或数据被删完了。 | 引导文案 + 创建入口（别只放个插图发呆）。 |
| **Loading (载入)** | 正在获取数据。 | 骨架屏或进度条（超过 1s 必须有反馈，可取消）。 |
| **Streaming (流式)** | AI 正在吐字，尚未完成。 | 停止按钮 + 自动滚底开关 + 增量渲染内容。 |
| **Partial (部分)** | 加载了一半挂了，或被中断。 | 保留已加载内容 + 重试剩余部分入口。 |
| **Error (失败)** | 彻底挂了。 | 错误原因（人话）+ 恢复动作（重试/反馈）。 |
| **Success (成功)** | 任务完成。 | 结果展示 + 下一步推荐（复制/分享/开始新任务）。 |

**可执行动作：让 Gemini 生成补丁**
当你有了规格，用 AI 直接生成代码补丁，而不是全文件覆盖。

```bash
# 示例：把规格转为状态完备的组件代码
gemini -m gemini-3-pro-preview -p "
你是一个资深前端工程师。基于以下 UI 规格，生成 React 组件代码。

规格：
1. 目标：展示 AI 生成的分析报告。
2. 状态要求：
   - Loading: 显示骨架屏。
   - Streaming: 显示打字机效果，必须有'停止生成'按钮。
   - Error: 显示红色错误框，必须有'重试'按钮。
   - Empty: 显示'暂无报告'，提供'新建分析'按钮。
3. 约束：
   - 使用 Tailwind CSS。
   - 严禁硬编码颜色，只能用 bg-blue-500 等标准类。
   - 必须包含所有状态的分支逻辑。

输出要求：
- 只输出组件代码，不要解释。
- 使用 TypeScript 接口定义 Props。
" > ui_component.tsx
```

## 步骤二：Design Tokens（设计即约束）

当你的项目超过 5 个页面，一致性维护成本就会指数级上升。解决办法不是“规范文档”，而是**Design Tokens**——一份定义 UI 唯一事实来源的 JSON 文件。

![图 6-2：Design Tokens 出码流水线](../../assets/figure_06_2_tokens_pipeline.svg)
> **Image Prompt:** A pipeline diagram. Input: JSON file labeled "Tokens". Processing node: "Build Script". Outputs: three branches labeled "CSS Variables", "iOS definitions", "Android XML". Arrows show flow. Tech schematic style.

### 为什么是 JSON？
因为 JSON 机器可读。你可以写个脚本自动生成 CSS、iOS 变量，甚至自动生成 AI 的 Prompt 约束。

### 模板 3：最小 Token 结构
存为 `tokens.json`。

```json
{
  "color": {
    "primary": { "value": "#2563EB", "comment": "主品牌色" },
    "error": { "value": "#DC2626", "comment": "错误提示背景" },
    "text": {
      "main": { "value": "#1F2937", "comment": "正文颜色" },
      "sub": { "value": "#6B7280", "comment": "次要信息颜色" }
    }
  },
  "spacing": {
    "unit": { "value": "4px", "comment": "基准单位" },
    "md": { "value": "16px", "comment": "标准间距" }
  }
}
```

### 可执行示例：Token 转 CSS 变量
别手动抄写 CSS 变量，用脚本转。

**脚本：** `tools/tokens_to_css.py` (假设文件内容如下)
```python
import json, sys

def to_css(data, prefix="--"):
    css = []
    for key, value in data.items():
        if isinstance(value, dict) and "value" in value:
            css.append(f"{prefix}{key}: {value['value']};")
        elif isinstance(value, dict):
            css.extend(to_css(value, f"{prefix}{key}-"))
    return css

if __name__ == "__main__":
    tokens = json.load(sys.stdin)
    print(":root {")
    print("\n".join(["  " + line for line in to_css(tokens)]))
    print("}")
```

**运行命令：**
```bash
# 验证 JSON 格式并生成 CSS
cat docs/examples/ui/tokens.sample.json | python3 tools/tokens_to_css.py > docs/assets/generated/variables.css

# 验证生成结果非空
if [ -s docs/assets/generated/variables.css ]; then echo "CSS Generated Successfully"; else echo "Failed"; fi
```

## 步骤三：可访问性（A11y）作为门禁

把 A11y 当作“底线”而不是“爱心工程”。如果键盘选不中按钮，说明你的 DOM 结构是乱的；如果读屏器读不出来，说明你的语义标签是错的。这些问题不仅影响视障用户，也影响自动化测试脚本的稳定性。

**最小验收清单（Fail 一项即回滚）：**
1.  **键盘可达**：丢掉鼠标，只用 Tab 能不能走完主流程？Enter 能不能提交？Esc 能不能关弹窗？
2.  **焦点可见**：当前选中的元素有没有明显的轮廓？（别为了美观把 `outline: none` 全局干掉）。
3.  **标签完整**：所有 `input` 都有 `label` 吗？所有图标按钮都有 `aria-label` 吗？
4.  **对比度**：灰底上的灰字，你自己看得清吗？（工具：Lighthouse 自带检查）。

**自动化策略：**
在 CI/CD 里集成 `axe-core` 或 `pa11y`。不要试图人工检查每一个页面，那是浪费生命。

## 步骤四：回归策略与 AI 辅助

UI 回归最怕“温水煮青蛙”：今天歪 1 像素，明天色号偏一点，一个月后这就成了个山寨站。

### 1. 组件级回归（Storybook）
对原子组件（Button, Input, Card），用 Storybook 录入所有状态（特别是 Error 和 Loading 态）。
*   **门槛**：每个组件必须有一个 Story 展示其“最丑”的状态（文案超长、容器极窄、报错红框）。

### 2. 页面级回归（AI 视觉比对）
传统 diff 工具太敏感，稍微改个 padding 就报错。用 AI 做语义级视觉回归。

**Prompt 示例（用于审视截图差异）：**
```text
对比这两张 UI 截图（Base vs Current）。
忽略 2px 以内的像素偏移和渲染抗锯齿差异。
重点检查：
1. 是否有文字重叠或遮挡？
2. 关键按钮（提交、取消）是否还在可视区域？
3. 颜色对比度是否明显下降？
如果发现上述严重问题，请输出 FAIL 并说明原因；否则输出 PASS。
```

## 交付物自检清单

在把 UI 代码合入主分支前，请对着镜子问自己：

1.  **规格查了吗？** 失败状态和恢复入口写进代码了吗？
2.  **约束守了吗？** 新增的颜色都在 Token 列表里吗？
3.  **键盘试了吗？** 不用鼠标能跑通这个功能吗？
4.  **极端情况测了吗？** 断网、报错、返回空数据，页面崩了吗？

## 下一章
UI 只是皮囊，工程才是骨骼。当你把界面变成可管理的资产后，我们需要谈谈如何用工程手段保证这一切能持续运转。下一章：[07-engineering.md](07-engineering.md)。

## 参考
详见本书统一参考文献列表：[references.md](references.md)。
