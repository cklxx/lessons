# 第 4 章：原型与信息架构：用最小成本验证路径
![Chapter 4 Header](../../assets/chapter_04_header_1766035396981.png)

> 原型的价值不是看起来像，而是用最小成本验证关键路径、信息架构与错误恢复：用户能不能走到价值、走错了能不能回来。[4][16]

在 0→1 阶段，你最稀缺的不是设计技巧，而是注意力。原型的任务，是把注意力从想象的用户拉回真实的路径：用户从哪里进来、要做什么、在哪一步犹豫、失败后怎么自救。

## 章节定位
上一章你已经把 PRD 写成了最小合同，知道做到什么算完。这一章做的事更朴素：用最小原型验证能不能发生。如果你发现关键路径走不通，最划算的修复方式往往不是加功能，而是改路径：入口、信息层级、状态与错误恢复。[16][17]

## 你将收获什么
- 一套三张纸原型法：页面树、用户流（含异常流）、状态清单。
- 一份原型走查脚本：用任务驱动替代审美争论，让反馈可复核。
- 一张原型通过门槛：什么情况下可以进入验证与打磨，什么情况下必须回到 PRD 重写。

## 三层思考：原型到底在验证什么
### 第 1 层：读者目标
读完本章，你应该能做出一个能跑通关键任务的原型，并且能回答：
- 用户是否能在不被指导的情况下完成任务？
- 他们在哪一步卡住、为什么卡住、卡住后如何恢复？

### 第 2 层：论证链条
原型验证的逻辑链条是：

页面树（信息架构）→ 用户流（主流程+异常流）→ 状态清单（空/加载/成功/失败/无权限）→ 走查脚本（任务驱动）→ 证据（录屏/笔记/问题清单）

缺任何一环，反馈都会变成感觉和审美，无法指导下一步决策。[16][17]

### 第 3 层：落地与验收
原型不是做完就好，而是能走查、能复核、能产生下一步结论。你需要明确门槛：原型过了什么条件才能进入下一章的验证与打磨。[4]

## 方法论速览：三张纸 + 一次走查
![图 4-1：三张纸（页面树/用户流/状态清单）关系示意（占位）](../../assets/figure_04_1_1765970865282.png)

## AI 产品的关键时刻：在原型里先把不确定性与纠错画出来
传统软件原型常常只需要验证路径是否顺畅；而 AI 产品还必须验证一件更棘手的事：**当系统不确定、出错、或需要用户补信息时，用户能不能继续走下去**。这不是上线后再补的体验优化，而是原型阶段就该验证的主路径。[71][72]

一个很实用的走查视角是把原型按三个关键时刻切开：
1. **首次接触**：用户是否理解它能做什么/不能做什么，能否找到起步动作。
2. **正在执行**：系统在做什么、需要多久、用户能否打断/改条件/补信息。
3. **结果交付**：用户如何判断对错、如何最小粒度修正、如何撤销/回退。[71]

![图 4-1b：AI 关键时刻地图（首次接触/执行中/结果交付）示意（占位）](../../assets/figure-placeholder.svg)

作图提示：把一条用户流画成三段（进入/执行/交付），每段标出系统提示、用户可动作、失败恢复入口、证据/日志点；用红色标出高风险不确定点，用绿色标出自救出口。[71][72]

你不一定要画复杂图，但建议你至少把这三段写成一张表：每一格都要出现下一步入口和失败恢复，否则 AI 场景的风险会在上线后以十倍成本补回来。[71][72]

| 关键时刻 | 系统必须表达清楚 | 用户必须能做的动作 | 失败时的恢复入口 |
| --- | --- | --- | --- |
| 首次接触 | 能做什么/不能做什么；从哪一步开始 | 选择示例/输入最小信息/开始任务 | 查看示例、回到首页、联系支持 |
| 正在执行 | 正在做什么；预计多久；是否可取消/修改条件 | 取消、补信息、重试、切换方案 | 中断后可继续/可重试；错误原因可读 |
| 结果交付 | 结果结构与依据；不确定时如何追问 | 复制/保存/导出；标注有用/无用；最小修改 | 撤销/回退、重新生成、回到上一步 |

### 1) 页面树：先定信息架构，再谈细节
用一张页面树把产品的信息层级写清楚：有哪些页面、如何分组、关键任务从哪里进入。页面树的作用是避免功能堆砌，也避免你在实现阶段才发现导航绕路。

**模板：页面树（信息架构）**

| 分组 | 页面 | 入口 | 用户要完成的任务 | 备注（风险/依赖） |
| --- | --- | --- | --- | --- |
| Onboarding | 注册/登录 | 首页 CTA | 进入系统 | 异常：验证码/频控 |
| Core | 核心任务页 | 导航/快捷入口 | 完成一次关键任务 | 必须可恢复失败 |
| Settings | 设置 | 头像菜单 | 账号/权限/计费 | 影响合规与风控 |

### 2) 用户流：强制写异常流
用用户流把关键链路写成步骤：用户做什么、系统反馈什么、下一步是什么。关键是：**异常流必须具名**，至少覆盖：
- 输入无效（用户能否理解并修复）
- 网络/超时（是否可重试、是否会丢数据）
- 权限不足（是否给出申请/替代路径）
- 没有结果（用户如何继续推进）[17]

**模板：用户流（主流程 + 异常流）**

| 步骤 | 用户动作 | 系统反馈 | 下一步 | 异常与恢复（至少 1 条） |
| --- | --- | --- | --- | --- |
| 1 | 选择入口 | 展示引导 | 进入任务页 | 入口找不到：提供快捷入口 |
| 2 | 填写/导入 | 校验与提示 | 提交 | 校验失败：指出原因+修复建议 |
| 3 | 提交 | 进度与预期 | 展示结果 | 超时：保留现场+重试 |

### 3) 状态清单：把缺状态当成缺需求
原型阶段最容易漏的是状态：空、加载、失败、无权限。漏掉状态的代价会在实现阶段爆炸式增长，因为它直接影响用户能否走回来。[17]

**模板：状态清单（页面/组件）**

| 页面/组件 | 空 | 加载 | 成功 | 失败 | 无权限 | 恢复入口 |
| --- | --- | --- | --- | --- | --- | --- |
| 核心任务页 | 有 | 有 | 有 | 有 | 有 | 重试/返回/求助 |

### 4) 走查脚本：用任务驱动替代审美争论
原型走查不要问你觉得怎么样，要给一个任务：让对方完成一次关键闭环。你观察的不是喜欢不喜欢，而是：
- 他们是否知道下一步是什么；
- 他们何时停顿、何时误点、何时放弃；
- 失败后是否能自救。

**模板：原型走查脚本**

| 任务 | 你的提示（一句话） | 你要观察什么 | 成功判定 | 失败判定 |
| --- | --- | --- | --- | --- |
| 完成首次任务 | 请用它完成 X | 是否迷路、是否犹豫、是否能恢复失败 | 无指导完成 | 卡住超过 2 分钟仍无路 |

![图 4-2：走查记录与断点标注（占位）](../../assets/figure-placeholder.svg)

!!! note
    作图提示：建议画成原型截图加断点标注，方便复盘与派发任务。
    - 左侧：一张关键页面截图（低保真即可）
    - 右侧：断点列表（断点 ID、触发条件、用户行为、系统应给的恢复入口）
    - 用编号把截图上的卡点位置与断点列表对应起来（方便复盘与派发任务）

### 4.5) 走查记录：把反馈从观点变成可修的断点
走查结束后，你要立刻把反馈从主观评价翻译成可修复的断点。否则你会陷入一种看似忙碌、实际无效的状态：每个人都给了很多建议，你也都觉得有道理，但下一步改什么、怎么判定改对了，完全说不清。

建议你用一个很朴素的断点记录表，把每个问题写到能行动的程度：

| 断点 ID | 发生在哪一步 | 用户当时想做什么 | 他实际做了什么 | 系统缺了什么 | 修复方向 | 验收方式 |
| --- | --- | --- | --- | --- | --- | --- |
| BP-01 | 首次进入 | 找到入口开始任务 | 四处点击导航 | 缺下一步引导 | 增加引导/示例 | 走查复跑不再迷路 |

你会发现：一旦把问题写到系统缺了什么，很多争论会自动消失——因为它回到了可验证的体验事实，而不是审美偏好。[4]

### 5) 原型输出：尽量低保真，但必须可走通
0→1 原型最容易陷入精修。原则是：**保真度只服务于验证**。只要能走通关键路径、能触发关键状态、能被走查脚本覆盖，就足够进入下一章的验证与打磨。

### 5.5) 原型里的文案与示例不是装饰，而是导航
对 AI 产品尤其如此：用户第一次打开时，最怕的是不知道从哪里开始。在原型阶段，你就应该把示例、空状态、第一步引导画出来并走查验证，因为它们决定了首日能不能发生闭环。

你不需要写出完美文案，但要在原型里明确三件事：
- **我现在要输入什么**（给一个可复制的示例）
- **系统会给我什么**（给一个结果示例或结构）
- **失败了我能怎么办**（给一个可恢复入口）

![图 4-3：空状态与示例的原型占位（占位）](../../assets/figure-placeholder.svg)

!!! note
    作图提示：建议画成三块区域，分别解决起步、示例与失败恢复。
    - 空状态：告诉用户这里能做什么
    - 示例区：提供 1–3 个可直接点击/复制的示例任务
    - 失败恢复：显式放出重试/查看示例/联系支持等入口（避免用户无路可走）

你可以用一个非常朴素的三块布局来检查自己有没有把导航画出来：

```text
[空状态：这里能做什么？一句话 + 一个起步动作]

[示例区：示例 1 / 示例 2 / 示例 3（可点击/可复制）]

[失败恢复：重试 | 查看示例 | 联系支持 | 返回上一步]
```

## 原型通过门槛（什么时候可以进入下一章）
- 页面树清晰：关键任务入口唯一且可解释。
- 用户流完整：主流程 + 异常流覆盖至少 3 类失败（输入、网络/超时、权限/无结果）。[17]
- 状态齐全：关键页面至少覆盖空/加载/成功/失败/无权限，并有恢复入口。[17]
- 走查可复核：至少 5 次任务走查有记录（录屏/笔记/问题清单），能提炼出断点列表。[4]

## 常见陷阱（失败样本）
1. **现象**：原型很好看，但走查时用户仍然迷路。  
   **根因**：信息层级与入口设计不清晰；你验证了视觉而不是路径。  
   **修复**：回到页面树与用户流，先改路径与状态，再改样式。[16]

2. **现象**：走查反馈很多，但无法行动。  
   **根因**：你问的是观点（像不像、好不好看），不是任务（能不能完成）。  
   **修复**：把反馈改写为断点 + 触发条件 + 恢复路径，并进入下一章的迭代卡片。[4]

3. **现象**：实现阶段才发现缺大量状态与错误处理。  
   **根因**：原型只画成功路径；把失败当实现时再说。  
   **修复**：在原型阶段强制补齐异常流与状态清单；缺状态视为缺需求。[17]

## 交付物清单与验收标准
- 页面树（信息架构）与关键入口说明。
- 用户流（含异常流）与恢复入口标注。
- 状态清单（关键页面/组件的空/加载/成功/失败/无权限）。
- 走查脚本与记录（至少 5 份），输出断点列表。

## 下一章
当原型证明路径能走通，下一步是把它变成闭环能稳定发生：建立指标树、写迭代卡片、用门槛裁决打磨。下一章见：[`05-validation.md`](05-validation.md)。

## 参考
详见本书统一参考文献列表：[`references.md`](references.md)。
