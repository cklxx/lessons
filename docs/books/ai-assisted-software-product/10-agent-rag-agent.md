# 第 10 章（Agent 深入）：让模型在边界内“会做事”

> Agent 不是“让模型更勤奋”，而是让它在边界内行动：能做什么、不能做什么、做到哪一步停、出了问题怎么回滚。越权与不可追溯，是 Agent 的原罪。[29][6]

很多 Agent 的失败不是因为模型不够强，而是因为系统设计太宽松：工具随便调、参数随便填、预算没有上限、失败没有停止条件。你会得到一个看似聪明、实际不可控的“自动化事故制造机”。

## 章节定位
本章是第 10 章的深入版，聚焦 Agent 的“行动闭环”：工具白名单、权限边界、预算与停止条件、审计与回滚，以及如何把这些写进评测门禁。它与后端与合规章节强相关，但这里先把 Agent 的通用骨架写清楚。[29]

## 你将收获什么
- 一套 Agent 的最小骨架：任务定义 → 状态机 → 工具边界 → 停止条件 → 审计落盘。
- 一份“工具合同”模板：每个工具都有输入/输出/权限/副作用/预算。
- 一套回归门禁：越权、注入、无限循环、成本失控都能被拦在上线前。[6][29]

![图 10-3：Agent 骨架（状态机 + 工具合同 + 预算/审计/回滚）示意（占位）](../../assets/figure_10_3_1765971191769.png)

## 三层思考：Agent 的关键矛盾
### 第 1 层：读者目标
你要交付的是“可托付的行动者”：它能完成任务，但更重要的是它知道什么时候不该做、做不下去怎么办、做错了怎么撤回。

### 第 2 层：论证链条
Agent 的可控链条是：

任务边界 → 工具合同 → 状态机与停止条件 → 输入不可信处理（注入/越权）→ 审计与回滚 → 评测回归

只要你缺“工具合同”和“停止条件”，其他一切都会变成不可预测的漂移。[29][6]

### 第 3 层：落地与验收
验收看三件事：
- 工具调用是否都在白名单与权限内；越权即阻断。[29]
- 是否有预算上限与停止条件；无限循环/过度调用即失败。[6]
- 关键行动是否可追溯可撤回；不可回滚即不该自动化。

## 第一步：先问“真的需要 Agent 吗”
很多时候你需要的不是 Agent，而是：
- 更好的产品流程（把任务拆短、把输入做对）；
- 更好的 RAG 证据链（减少编造）；
- 更好的后端能力（提供更明确的接口与错误语义）。[6]

如果“用户只要一个答案”，用 RAG；如果“系统必须做一串动作”，才考虑 Agent。

## 第二步：写工具合同（工具是风险源，不是能力源）
把每个工具当成“有副作用的外部系统”。工具合同至少要写清楚：
- 工具做什么、不做什么；
- 需要什么权限与范围；
- 输入输出的结构与校验；
- 成本预算与停止条件；
- 副作用如何撤回/补偿（回滚）。[29]

**模板：工具合同（工具白名单）**

| 字段 | 说明 |
| --- | --- |
| 工具名 | 唯一标识 |
| 目的 | 一句话说明用途 |
| 允许动作 | 读/写/删除/支付等（尽量最小） |
| 权限范围 | 用户/租户/资源级限制 |
| 输入校验 | 必填字段、格式、长度、白名单 |
| 输出语义 | 成功/失败与原因，是否可重试 |
| 预算与停止 | 最大调用次数/最大成本/超时 |
| 副作用 | 会改变什么；如何撤回/补偿 |
| 审计字段 | 需要记录哪些信息用于追责 |

## 第三步：做一个“可解释的状态机”
Agent 不应该是无边界的自由发挥。最实用的做法是把它写成状态机：每一步明确输入、输出与停止条件。

**模板：Agent 状态机（最小可控版）**

| 状态 | 进入条件 | 行为 | 成功退出 | 失败退出（必须有） |
| --- | --- | --- | --- | --- |
| 收集信息 | 输入不足/不确定 | 追问/补齐 | 信息齐全 | 超时/拒答 |
| 计划 | 任务明确 | 生成步骤列表 | 计划可执行 | 计划包含越权动作 |
| 执行 | 计划已定 | 调用工具（白名单） | 得到结果 | 工具失败/预算越界 |
| 总结 | 有结果 | 解释+证据+下一步 | 交付 | 不确定则回到追问 |

“状态机”的价值在于：它让你能写评测、能回归、能定位，而不是把系统交给不可预测的自由对话。

## 第四步：预算与停止条件（防止“勤奋导致破产”）
Agent 最危险的不是“不会做”，而是“做太多”：反复思考、反复检索、反复调用工具。最低止损要求：
- 每次任务有最大步骤数/最大工具调用次数；
- 每次任务有最大成本/最大时间；
- 达到上限必须停止，并给出“下一步建议”。[6]

**模板：预算与停止条件**

| 维度 | 阈值 | 触发后动作 |
| --- | --- | --- |
| 工具调用次数 | ≤ N | 停止并解释原因 |
| 总成本 | ≤ X | 降级/请求确认/停止 |
| 总时长 | ≤ T | 返回部分结果 + 建议 |
| 失败次数 | ≤ M | 切换策略或停止 |

## 第五步：审计与回滚（让自动化可追责）
Agent 的每一次行动都应该可追溯：谁触发、对什么资源、做了什么、结果如何、用了什么参数。更重要的是：当行动有副作用时，你必须设计“撤回/补偿”。[29]

最低审计原则：
- 工具调用必须记录输入、输出、结果与原因；
- 关键资源操作必须记录资源标识与权限上下文；
- 任何涉及计费/删除/权限变更的动作，默认需要更强的审计与更强的回滚策略（甚至需要人工确认）。[6]

## 安全：把输入当作不可信，把工具当作高风险
Agent 的两类常见事故：
- **输入注入**：用户用指令诱导越权或泄露。
- **工具滥用**：工具参数被注入，导致访问不该访问的资源。[29]

最低防护：
- 工具层做权限校验与输入校验（不要只在提示里“说不要”）。
- 任何越权尝试都要阻断并记录，且进入回归集。[6][29]

## 评测与回归：Agent 的门禁比 RAG 更硬
Agent 的评测不止看“答得对不对”，还要看“做得安不安全”：
- 越权率（必须为 0 或可解释豁免）
- 预算越界率（必须可控）
- 副作用可回滚率（关键动作必须可撤回）
- 失败恢复质量（是否能停止并给出下一步建议）[6]

## 复现检查清单（本章最低门槛）
- 每个工具都有工具合同：权限/输入校验/预算/副作用/审计字段齐全。[29]
- Agent 有状态机与停止条件；无限循环与预算越界可被门禁拦截。[6]
- 越权与注入样本进入回归集：命中即阻断发布。[6][29]

## 常见陷阱（失败样本）
1. **现象**：Agent 偶尔做出危险操作（越权/误删/误发）。  
   **根因**：把安全写在提示里，而不是写在工具与权限层。  
   **修复**：工具层强校验 + 审计 + 回滚；越权命中即阻断。[29]

2. **现象**：Agent 表现“很努力”，但成本失控、延迟巨大。  
   **根因**：无预算与停止条件；把循环当聪明。  
   **修复**：写预算上限与停止条件；越界必须停止并解释。[6]

3. **现象**：出了事故无法复盘，只能猜。  
   **根因**：缺审计字段；工具输入输出不可追溯。  
   **修复**：补齐审计与可重放记录；把“可追责”当成功条件。[29]

## 交付物清单与验收标准
- 工具合同库（白名单）：至少覆盖 5 个关键工具。[29]
- Agent 状态机与停止条件说明（含预算与降级）。[6]
- 回归集：越权/注入/预算越界/失败恢复样本，命中即阻断发布。[6][29]

## 下一章
Agent 与 RAG 让系统“能回答、能行动”。接下来进入产品模块：身份与权限，是一切边界与审计的底座。下一章见：[`11-user.md`](11-user.md)。

## 参考
详见本书统一参考文献列表：[`references.md`](references.md)。
