# 第 10 章：Agent 架构与 RAG：证据、边界与回归
![第 10 章封面](../../assets/chapter_10_header_1766035645245.png)

> RAG 解决回答要有证据，Agent 解决让模型会做事。两者最难的不是能不能跑，而是能不能长期稳定地跑：证据链、权限边界、评测门禁缺一不可。[6][24][29]

这一章给你一条主线：当你遇到幻觉、注入、越权、成本飙升、延迟变差时，应该先看哪一环；也给你一套决策框架：什么时候该用 RAG，什么时候该用工具（Agent），什么时候应该回到产品设计与数据质量上重做。

## 章节定位
本章位于全栈底座之后，开始进入智能层。它不追求把你带进某个框架的细节，而是把智能层写成可治理系统：
- **证据链**：回答能回指到来源片段；无引用视为失败。[24]
- **边界**：工具调用有白名单、Schema、预算与停止条件；越权视为阻断。[29]
- **回归**：改动前后同口径对比；退化即回滚。[6]

这里的全栈底座指的是：工程化门禁（Ch07）+ 前端可解释体验（Ch08）+ 后端错误语义/幂等/可观测/预算（Ch09）。没有这些底座，智能层只会把不确定性放大到线上。

更细的实现与陷阱分别放在两章深入：
- RAG 深入：[`10-agent-rag-rag.md`](10-agent-rag-rag.md)
- Agent 深入：[`10-agent-rag-agent.md`](10-agent-rag-agent.md)

## 你将收获什么
- 一张端到端闭环：数据进入、检索、生成、工具调用、审计落盘、评测回归。
- 一套最小门禁：无引用即失败、非法工具调用阻断、失败样本集回归。
- 一张选型决策表：面对不同问题，先选 RAG、Agent 还是别做智能。[6]

## 三层思考：把聪明变成可控
### 第 1 层：读者目标
你要让用户得到两种确定性：
- 结果的确定性：有证据、可追溯、可复核。
- 行为的确定性：能做什么、不能做什么、做到哪一步就停止。[29]

### 第 2 层：论证链条
智能层的闭环是：

任务定义 → 失败模式 → 证据链（RAG）→ 行为边界（Agent）→ 评测门禁 → 线上审计与观测 → 退化回滚

你会发现：只要评测与审计缺失，任何优化都会变成不可解释的漂移。[6]

### 第 3 层：落地与验收
验收不靠感觉更聪明，而靠门槛：
- 回答必须带引用（或明确拒答/追问）；无引用=失败。[24]
- 工具调用必须在白名单与预算内；越权=阻断。[29]
- 改动必须过回归集；退化=回滚。[6]

![图 10-1：智能层端到端闭环（证据链/边界/评测/审计）示意](../../assets/figure_10_1_1765971099603.png)

## 智能层的定义与边界
本书中智能层指的是：把模型能力嵌入系统，并让它在可审计与可回滚的约束下工作的一组组件。最小组成只有四块：

- 检索与证据：把回答绑定到来源片段，证据不足就追问或拒答。[24]
- 工具与行动：把可做的事收敛成白名单工具，并把入参、权限与预算写成合同。[29]
- 评测与回归：用失败样本集与固定口径做门禁，避免漂移。[6]
- 审计与观测：把检索、引用、工具调用与成本写入审计事件，能复盘能追责。[29]

## 先做决策：你到底需要 RAG 还是 Agent
### 决策表：先问你缺的是信息还是能力

| 你遇到的问题 | 更可能的解法 | 混合策略（常见） | 风险与门禁 |
| --- | --- | --- | --- |
| 回答缺事实、编造引用 | RAG | 先检索再生成 | 无引用强答视为失败[24] |
| 需要调用外部系统完成任务 | Agent | 先检索上下文，再工具写操作 | 非法工具调用与越权阻断[29] |
| 输出不稳定、风格漂移 | 评测与回归先行 | 固定回归集 + A/B | 无基线不宣称优化[6] |
| 成本与延迟失控 | 预算与降级先行 | 缓存 + 分层模型 + 降级路径 | 越界即降级/回滚[6] |
| 用户不信任、不敢用 | 证据与边界先行 | 证据卡片 + 工具时间线 | UI 必须可解释可自救 |

## 最小门禁（建议先落地这 5 条）
1. **引用缺失 = 失败**：无引用不合并、不上线（知识问答尤甚）。[24]
2. **非法工具调用 = 阻断**：不在白名单/入参不匹配/权限不足，直接失败并记录审计。[29]
3. **失败样本集回归**：每次改动必须通过固定失败集（注入、长上下文、边界语义、越权尝试）。[6]
4. **成本/延迟守门**：每次改动提供同口径对比表（质量/延迟/成本），退化即回滚。[6]
5. **审计可追责**：关键动作（检索、工具、引用）可追溯可重放。[29]

## 威胁模型速查：默认会发生的攻击
智能层上线后的事故，往往不是“模型太笨”，而是攻击面没被当成一等公民：自然语言输入、外部语料与工具调用叠加后，你必须假设攻击一定会发生，并把防御做成自动化门禁。[29]

| 威胁/攻击面 | 最小复现（Min Repro） | 离线回归样本（必须固化） | 线上信号（Online Signal） | 阻断门禁（Blocking Gate） | 默认回滚/降级 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| Prompt 注入 / 越狱 | 用户输入：要求忽略指令、泄露系统提示词、绕过边界 | 注入攻击集（短指令/长指令/混合语言/编码） | 拒答率异常下降、出现“系统提示词特征串” | 输出审计：命中泄露特征或越权意图即拦截 | 返回固定错误提示；必要时强制切只检索 |
| 上下文污染 / 语料投毒 | 语料含“隐蔽指令”（白字/脚注/HTML 隐藏）诱导输出错误结论 | 投毒样本集（PDF/HTML/代码块/表格） | 事实一致性下降、引用片段与结论矛盾 | 引用一致性：结论中强断言必须能在引用片段中定位 | 降级为“只给出处不下结论”或拒答/追问[24] |
| 工具参数注入 | 诱导模型生成危险参数（SQL/CLI/URL） | 工具边界样本（危险参数/边界值/空值/超长） | 写/删类工具调用比例抬升、异常重试增多 | Schema 校验 + 权限校验：不通过即阻断[29] | 拒绝执行并提示需要人工确认 |
| 资源耗尽 / 死循环 | 指令诱导反复思考/检索/调用工具 | “循环诱导”任务集（要求完美、反复验证、无限细化） | Tool call 次数/耗时/token 速率异常飙升 | 预算熔断：最大步数/最大 token/最大时长硬顶[6] | 强制停止，返回中间结果 + 下一步建议 |
| 越权与数据外泄 | 用户诱导访问不属于其租户/权限的数据 | 越权样本集（tenant mismatch / role escalation） | 审计中出现敏感资源访问尝试 | RBAC/ABAC 强制校验：命中即阻断并报警 | 关闭写操作工具；仅保留只读查询 |

**安全验收检查清单（合并前必须全绿）**
- [ ] 输入清洗：移除/规整控制字符、超长输入、可疑编码片段；不足则直接截断并要求用户确认。
- [ ] 输出脱敏：PII/密钥/系统提示词特征命中即拦截或遮罩。[24]
- [ ] 工具沙箱：写操作工具默认 require confirmation；执行环境最小权限、最小网络面。[29]
- [ ] 预算硬顶：max_steps/max_tool_calls/max_tokens/max_time 必须由系统强制，不可被模型覆盖。[6]
- [ ] 攻击回归：注入/投毒/越权/死循环样本集固定可复跑，命中即阻断发布。[6]
- [ ] 线上可观测：审计事件可按 trace_id 串起检索/引用/工具调用/成本，支持复盘与追责。[29]

## 版本组合（Version Set）：让智能层可回滚
在智能层里，“回滚代码”通常不够：行为由**代码 + 模型 + 提示词/策略 + 索引/语料 + 工具合同**共同决定。要可回滚、可复现，必须把它们锁定为一个原子发布单元（版本组合），并在 PR/发布时强制校验。[29]

| 字段类别 | 字段名（建议） | 示例值 | 说明 |
| :--- | :--- | :--- | :--- |
| 基础模型 | `model_version` | `provider:model@2025-01-01` | 禁止使用 `latest`；必须精确到快照/日期 |
| 提示词/策略 | `prompt_or_policy_version` | `prompt:v12` | 与仓库内文件/ID 一一对应 |
| 推理参数 | `inference_profile` | `temp=0.2,top_p=0.9` | 口径一致：采样策略变化也算变更 |
| 索引/语料 | `index_snapshot` | `kb-snap-2025w01` | 必须可回溯到语料快照与构建参数 |
| 检索配置 | `retrieval_profile` | `top_k=8,rerank=v3` | 检索链路的参数也要版本化 |
| 工具合同 | `tools_schema_hash` | `sha256:<...>` | 工具白名单与 Schema 指纹 |
| 审计/守门 | `gate_profile` | `gates:v4` | 门禁阈值与阻断规则的版本 |

**最小校验（CI/发布前 1 条命令）**

```bash
python3 - <<'PY'
import json

p = "ai-lock.json"
v = json.load(open(p, encoding="utf-8"))
required = [
    "model_version",
    "prompt_or_policy_version",
    "index_snapshot",
    "tools_schema_hash",
    "gate_profile",
]
missing = [k for k in required if not str(v.get(k, "")).strip()]
if missing:
    raise SystemExit(f"missing fields: {missing}")
print("ok")
PY
```

**发布检查清单（版本组合）**
- [ ] 原子性：`ai-lock.json`（或 `manifest.json`）随代码同 PR 提交；缺失则拒绝合并。
- [ ] 可回滚：上一稳定版本组合可一键切回（配置/路由/发布系统支持）。
- [ ] 可复现：离线回归能用该版本组合复跑出同级别结论（同趋势、同阈值裁决）。[6]
- [ ] 可审计：线上事件能定位到版本组合 ID（用于对外解释与事故复盘）。[29]

## 把证据与行动做成产品体验：用户看见了，才会敢用
智能层最容易出现的产品错觉是：你在系统里做了很多治理（引用、工具白名单、审计），但用户完全看不见——他只看到一段回答（或一串动作），于是他无法判断它是否可靠，也无法在失败时自救。

更稳的做法是把证据链和行动链在 UI 上变成可理解的结构，让用户在关键时刻能回答三件事：
- **它凭什么这么说**：关键结论对应哪些来源片段（能点开、能核对）。[24]
- **它做了什么**：调用了哪些工具、每一步花了多久、哪一步失败（避免黑箱）。[29]
- **我下一步怎么办**：证据不足时追问；工具失败时重试/降级；权限不足时申请/切换账号。[6]

与其放一张占位图，不如先把 UI 结构写成可实现表格，保证每一块都有用户动作与失败恢复：

| 区块 | 用户看到什么 | 用户能做什么 | 系统留档什么 |
| --- | --- | --- | --- |
| 结果区 | 结论 + 下一步 | 复制/保存/继续 | 最终答案 + trace_id |
| 证据区 | 引用卡片（来源/片段） | 展开/跳转/核对 | sources + 命中片段 |
| 行动区 | 工具时间线（每步状态） | 重试/降级/取消 | tool_calls + 参数摘要 |
| 边界区 | 不确定性与风险提示 | 追问/补信息/改请求 | refusal_reason + 风险标记 |

把这三件事长在界面里，智能层才会从黑箱变成可托付系统：

```text
[结果区] 结论 + 下一步（先给可行动答案）

[证据区] 引用卡片（来源/段落摘要/命中高亮）— 无证据则明确提示不足

[行动区] 工具调用时间线（工具名/参数摘要/结果/失败原因）+ 可重试/可降级
```

## 关键流程图（纯文本）：智能层端到端闭环

```text
任务定义 -> 失败模式清单 -> RAG 证据链（召回/引用/拒答） -> Agent 行为边界（白名单/Schema/RBAC/预算）
  -> 离线回归与红队 -> 灰度发布 -> 线上审计与观测 -> 退化回滚 -> 失败样本回流

门禁（任一命中即阻断）：
- 无引用强答
- 非法工具调用或越权
- 预算越界且无降级/停止
- 缺对比证据却宣称优化
```

## 示例（可复制）：把最小门禁落成可执行规则

**目标：** 先落地本章最小门禁 5 条，让你敢迭代而不是靠运气上线。

**前置条件：**
- 你有一个智能层能力（RAG 或 Agent），并愿意把失败样本资产化
- 你能在项目里固定一个回归集与门禁入口

**输出格式：**
- 门禁规则：`docs/intelligence/gates.md`
- 失败样本集：`docs/intelligence/regression.jsonl`
- 审计字段合同：`docs/intelligence/audit-fields.md`
- 版本组合说明：`docs/intelligence/version-set.md`

**步骤：**
1. 把 5 条门禁写成规则与阻断条件（无引用强答、非法工具调用、失败样本回归、成本/延迟守门、审计可追责）。[6][24][29]
2. 为每条门禁准备最小样本：缺证据、注入、越权、长上下文、预算越界，命中即阻断。[6]
3. 把门禁接入发布流程：无门禁结果/无对比表/无证据包，不允许灰度与全量。[6]

**验证命令：**
```bash
python3 - <<'PY'
from pathlib import Path

gates = Path('docs/intelligence/gates.md')
if not gates.exists():
  raise SystemExit('missing docs/intelligence/gates.md')

text = gates.read_text(encoding='utf-8', errors='replace')
must = ['无引用', '非法工具', '回归', '成本', '审计']
missing = [k for k in must if k not in text]
if missing:
  raise SystemExit(f'missing gate keywords: {missing}')

print('ok')
PY
```

**失败判定：**
- 门禁规则写不成可执行条件（只能写原则），或缺少阻断级样本。

**回滚：**
- 任一阻断级门禁失败，立即回滚到上一稳定版本组合，并把触发样本加入回归集变体，避免复发。[6]

## 复现检查清单（本章最低门槛）
- 证据与边界写成门禁规则：无引用强答=失败、非法工具调用=阻断、预算越界=降级/停止，并能在发布流程中执行。[6][24][29]
- 智能层版本可追溯：提示词、索引、模型与路由策略能组成版本组合并可回滚；缺版本组合视为不可灰度。[6]
- 回归与红队可复跑：失败样本集与攻击集固定可复跑，命中即阻断发布，并在一周内回写更多变体。[6]
- 审计可解释：检索、引用、工具调用与成本字段能用一次 trace_id 串起来，支持复盘与对外解释。[29]

## 常见陷阱（失败样本）
1. **现象：** 线上偶尔很准、偶尔翻车，用户不敢依赖。  
   **根因：** 没有失败样本资产化与回归门禁，优化只看平均指标，极端风险被均值稀释。[6]  
   **复现：** 同一类问题在不同输入长度/不同语料新鲜度下表现波动，缺少固定回归集导致无法解释差异。  
   **修复：** 建失败样本集 + 固定攻击集；回归不过不发布；对比表必须覆盖质量/延迟/成本。[6]  
   **回归验证：** 同一回归集在同口径下可复跑；退化触发回滚，且能定位到具体失败样本与原因。[6]

2. **现象：** Agent 很勤奋，但成本飙升且偶尔越权。  
   **根因：** 没有预算/停止条件与工具边界；把会做事当成该做事。  
   **复现：** 工具失败或弱网时循环重试；或在权限不足时仍尝试写操作，导致越权风险。  
   **修复：** 明确停止条件、预算与权限；非法工具调用与越权视为阻断级失败，并产出审计证据。[29]  
   **回归验证：** 越权/预算越界样本进入回归；命中即阻断发布，线上审计能解释每一次工具调用。[29]

3. **现象：** 你在系统里做了治理，但用户看不见，信任无法建立。  
   **根因：** 证据链、边界与审计只存在后端日志里；UI 不可解释，失败时无自救入口。  
   **复现：** 用户只能看到一段回答或一串动作，看不见引用与工具时间线，出现错误时只能重试或放弃。  
   **修复：** 把证据链与行动链做成 UI 结构（结果/证据/行动/边界），并把可恢复入口显式放在界面里。[24][29]  
   **回归验证：** 走查时用户能回答三件事：凭什么这么说、做了什么、下一步怎么办；失败样本可回流并复跑通过。

## 交付物清单与验收标准
- 智能层端到端闭环说明（含证据链、边界、评测门禁）。
- 最小门禁规则与阈值（引用/越权/回归/成本）。[6][24][29]
- 审计字段规范（检索、工具、引用可追溯）。

## 下一章
智能层之后，你会进入产品模块的世界：用户、权限、计费、数据等，把商业闭环与风险边界落到系统默认属性。下一章见：[11-user.md](11-user.md)。

## 参考
详见本书统一参考文献列表：[references.md](references.md)。
