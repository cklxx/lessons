# 第 11 章：用户模块：认证、授权与审计
![第 11 章封面](../../assets/chapter_11_header_1766035665346.png)

> 能登录不等于能上线。0→1 最容易出事故的地方往往是权限边界不清、审计缺失、账号体系一改就崩。本章把用户模块当作生产系统的底座来写：边界清晰、可追溯、可回滚。[22][68]

AI 产品会把用户模块的风险放大：一旦越权，泄露的不只是页面数据，还可能是知识库、提示词、工具调用结果与审计日志本身。你必须把默认安全做成系统属性，而不是靠记得这里要校验一下。[68]

## 章节定位
本章位于智能层之后，进入产品模块。原因很简单：只要你开始提供保存、共享、团队协作、计费或知识库，你就必须先把身份与权限边界写清楚。否则你后面的每一章都会在同一个地方反复返工：谁能看到什么、谁能做什么、出了事怎么追责。[22]

## 你将收获什么
- 一个可迁移的用户模块边界：AuthN/AuthZ 分层、租户隔离、资源级权限。
- 一套审计口径：关键事件、字段、追踪标识，让事故可复盘可追责。[68]
- 一张最小门禁：越权阻断、敏感操作可追溯、凭证策略可回滚。

## 三层思考：用户模块的价值不是登录，是边界
### 第 1 层：读者目标
你要交付的是一个可托付的系统底座：权限清晰、越权可回归、关键操作可追溯。

### 第 2 层：论证链条
用户模块的链条是：

身份体系（AuthN）→ 权限模型（AuthZ）→ 租户隔离 → 审计事件 → 回归用例 → 变更与回滚

缺一环，安全会变成人的记忆，而人的记忆在压力下最不可靠。[68]

### 第 3 层：落地与验收
验收不靠看起来没问题，而靠三条硬门槛：
- 任何跨租户访问都必须失败（服务端阻断，而不是 UI 隐藏）。[68]
- 敏感操作必须产生审计事件（谁、何时、对什么、做了什么、结果如何）。[68]
- 权限变更必须可灰度与可回滚（避免一改全崩）。

## 方法论速览：先定模型，再定事件，再写回归
![图 11-1：用户模块分层示意](../../assets/figure_11_1_1765971227695.png)

## 关键流程图（纯文本）：一次请求如何被允许/拒绝并可追溯

```text
请求（含凭证/tenant_id）
  ↓
AuthN（你是谁）
  - 校验凭证有效性（过期/撤销/轮换）
  - 失败：拒绝 + 记录审计（login_fail / token_invalid）
  ↓
AuthZ（你能做什么）
  - 取主体（user/service）→ 取资源（resource_id）→ 取动作（read/write/admin）
  - tenant_id 必须一致；资源级谓词必须成立
  - 失败：拒绝 + 记录审计（access_denied + reason + policy_version）
  ↓
执行（只在允许后发生）
  - 返回结果或业务错误（与权限错误区分）
  ↓
审计（可搜索、可串联、可解释）
  - who/when/where/what/action/result/reason/trace_id/policy_version
  ↓
回归与变更治理
  - 越权用例入回归：跨租户、降权后访问、敏感操作审计缺失
  - 策略版本化与灰度：新旧策略并行窗口 → 指标不退化才切换 → 退化即回滚
```

## 示例（可复制）：3 条阻断级权限回归（跨租户/越权/口径）

**目标：** 用最小回归集把“越权必失败”固化成可复跑门禁，并确保拒绝原因可解释（便于审计与对外沟通）。

**前置条件：**
- Python 3 可用

**步骤：**
1. 复制并运行下面脚本：它模拟一个最小 RBAC + 租户隔离，并验证 3 条回归用例。
```bash
python3 - <<'PY'
from __future__ import annotations

class Denied(Exception):
    def __init__(self, reason: str):
        self.reason = reason

def authorize(actor: dict, resource: dict, action: str, policy: dict) -> dict:
    if actor["tenant_id"] != resource["tenant_id"]:
        raise Denied("tenant_mismatch")
    allowed_actions = policy["roles"].get(actor["role"], [])
    if action not in allowed_actions:
        raise Denied("action_not_allowed")
    return {"allow": True, "policy_version": policy["version"]}

def must_allow(case: dict) -> None:
    try:
        out = authorize(case["actor"], case["resource"], case["action"], case["policy"])
    except Denied as e:
        raise SystemExit(f"UNEXPECTED DENY: {e.reason}")
    if out.get("policy_version") != case["expect_policy_version"]:
        raise SystemExit("WRONG POLICY VERSION")

def must_deny(case: dict, expect_reason: str) -> None:
    try:
        authorize(case["actor"], case["resource"], case["action"], case["policy"])
        raise SystemExit("UNEXPECTED ALLOW")
    except Denied as e:
        if e.reason != expect_reason:
            raise SystemExit(f"WRONG DENY REASON: got={e.reason} expect={expect_reason}")

policy = {"version": "p_001", "roles": {"owner": ["read", "write", "admin"], "viewer": ["read"]}}
resource = {"tenant_id": "t_001", "resource_id": "kb_1"}

must_allow(
    {
        "policy": policy,
        "actor": {"tenant_id": "t_001", "role": "owner"},
        "resource": resource,
        "action": "read",
        "expect_policy_version": "p_001",
    }
)

must_deny(
    {
        "policy": policy,
        "actor": {"tenant_id": "t_999", "role": "owner"},
        "resource": resource,
        "action": "read",
    },
    "tenant_mismatch",
)

must_deny(
    {
        "policy": policy,
        "actor": {"tenant_id": "t_001", "role": "viewer"},
        "resource": resource,
        "action": "write",
    },
    "action_not_allowed",
)

print("ok")
PY
```
2. 将这 3 条用例迁移到你的服务端授权层回归（真实 API/真实租户/真实资源），并把拒绝原因落到审计字段（`reason` + `policy_version` + `trace_id`）。
3. 权限策略变更必须先灰度：新旧策略并行一个窗口；回归全绿且线上拒绝率不异常，才允许切换。

**验证命令：**
- 上面脚本输出 `ok` 且退出码为 0；在你的工程中，对应回归任务应稳定通过。

**失败判定：**
- 任一越权用例被放行（出现 `UNEXPECTED ALLOW`），或拒绝原因/策略版本口径不一致（出现 `WRONG ...`）。

**回滚：**
- 立即切回上一策略版本（`policy_version` 回退），并在回归集中加入触发问题的最小用例；复跑通过才允许继续变更。

### 1) 身份体系（AuthN）：你是谁
AuthN 的核心是凭证生命周期：签发、过期、撤销、轮换。0→1 阶段不追求花哨，但必须可解释可撤销。[22]

如果你要接第三方登录或企业 SSO，建议优先选成熟的 OIDC 提供商，别在 0→1 阶段自己发明一套 token 协议。真正折磨人的不是登录页，而是撤销、轮换、过期后的边界：用户登出后旧会话是否还在，管理员禁用账号后旧 token 是否还能访问。把这些问题写进验收与回归，比多做两种登录方式更值钱。[22][69][68]

你要回答三件事：
- 你支持哪些登录方式（邮箱、第三方、企业 SSO）？
- 凭证如何失效（登出、改密、风控封禁）？
- 会话如何被追踪（用于审计与风控）？

一个更可落地的最小推荐是：短生命周期 access token + 可轮换 refresh token，并把撤销做成服务端事实而不是客户端愿望：
- access token 过期短一些（降低泄露窗口），refresh token 绑定设备与会话。
- refresh token 轮换：每次刷新都签发新 refresh token，旧 refresh token 立即失效，降低被盗复用风险。
- 撤销与封禁：服务端维护会话表或撤销列表，禁用用户时让所有会话立即失效（而不是等过期）。[69][68]

### 2) 权限模型（AuthZ）：你能做什么
推荐从最小可用三件套起步：
- 主体：用户、服务账号、团队。
- 资源：项目、文档、知识库、账单等资源实例。
- 动作：read、write、admin 等动作集合。[68]

最重要的不是你选 RBAC 还是 ABAC，而是：权限必须可测试、可审计、可迁移。

#### 权限模型一页纸

| 项目 | 写法 |
| --- | --- |
| 主体 | 用户/团队/服务账号的定义 |
| 资源 | 需要保护的资源清单与标识方式 |
| 动作 | read/write/admin 等最小集合 |
| 角色 | 角色与动作映射（可选） |
| 租户隔离 | tenant_id 如何贯穿与校验 |
| 默认策略 | 默认拒绝还是默认允许（推荐默认拒绝） |

!!! note "如何使用两栏权限视图"
    用“两栏 + 危险区”结构把权限变成可解释、可审计的产品能力：
    - **左栏（成员列表）**：邮箱/角色/状态（已邀请/已加入/已停用），支持搜索与筛选。
    - **右栏（权限详情）**：资源范围 + 动作集合，并明确“任何变更都会产生审计事件”。
    - **页底（危险操作区）**：移除成员/降权/停用必须二次确认 + 理由输入，避免事后扯皮。

在界面上，你可以把成员和权限做成一个可解释的两栏结构，让拒绝与变更都有出处：

```text
[成员列表：邮箱 | 角色 | 状态（已邀请/已加入/已停用）]
    ↓ 选中某成员
[权限详情：资源范围 + 动作集合 + 最近一次变更（审计链接）]

[危险操作区：移除成员/降权/停用]（二次确认 + 理由输入，写入审计）
```

如果需要一个更具体的起步示例，可以用 RBAC 做角色聚合，用资源级校验守住边界：

| 角色 | 允许动作（示例） | 资源范围（示例） |
| --- | --- | --- |
| owner | read/write/admin | 全项目 |
| editor | read/write | 被授予的项目/知识库 |
| viewer | read | 被授予的项目/知识库 |

关键是把资源范围写成可测试的谓词（例如 tenant_id 必须一致，resource_id 必须在授权集合内），并把越权用例资产化为回归集。[68]

## 把权限做成产品体验：用户要知道为什么不行和怎么继续
权限系统最常见的体验事故不是越权，而是误伤：用户被拒绝了，但不知道为什么；他去问你，你也只能说你没权限。这会直接伤害使用意愿，尤其在团队场景里——越多人协作，越需要一个可解释的拒绝。

在产品层面，你至少要做到三件事：
- 拒绝可解释：界面上把缺什么权限说清楚（缺角色/缺资源范围/账号被停用），并展示一个可操作的下一步。
- 下一步可行动：提供申请权限、联系管理员、切换工作区/账号的入口，而不是让用户只能退出。
- 变更可追溯：权限被赋予/撤销后，用户和管理员都能在审计里看到证据，避免口头扯皮。[68]

这类设计看起来不酷，但非常实用：它既减少工单，也让系统更符合人机协作的基本原则，系统要解释自己为什么这样做，并给用户一条能继续走的路。[71]

你可以把它当作减少支持成本的产品设计：把一次来回沟通，变成一次点击和一次审计记录。

## 邀请与协作：让加入团队像完成一次闭环一样顺
如果你的产品有团队/工作区概念，邀请流程往往决定了协作能否启动。0→1 阶段最容易忽略的细节包括：邀请链接过期、重复邀请、成员未激活但已占用席位、角色默认过大、以及邀请被转发导致越权。

一个可控、可解释的邀请闭环建议包含：
- 发起邀请（管理员选择角色/资源范围）→ 发送邀请 → 成员接受 → 首次登录/绑定 → 权限生效 → 产生审计事件。[68]
- 失败与恢复：链接失效/邮箱输错/成员已存在/成员拒绝/管理员撤销，都要有明确的恢复入口。

!!! note "如何使用邀请闭环状态机"
    把邀请当成一个有失败分支的状态机来设计与验收：
    - **主流程**：邀请 → 接受 → 加入 → 首次登录/绑定 → 权限生效 → 产生审计事件。
    - **异常与恢复**：过期/撤销/重复邀请/成员已存在必须各自有恢复入口（重发/撤销/改权限）。
    - **风险底线**：邀请默认最小权限；跨租户邀请必须服务端阻断并留审计。

把邀请流程写成可复盘的闭环，你就能避免大多数协作启动失败：

```text
状态机（invite）
  invited → accepted → joined → active
  invited → expired
  invited → revoked

异常与恢复
  重复邀请：按 (tenant_id, email) 做幂等，返回现有邀请并提示可撤销/重发
  成员已存在：切换为调整权限（产生审计事件）
  过期：重发邀请（新 token，旧 token 失效）
  跨租户：服务端阻断并记录审计
```

### 3) 租户隔离：0→1 最常见的致命漏洞
多租户产品里，最贵的事故是跨租户数据泄露。最低要求：
- 任何资源查询都必须带租户上下文；
- 任何缓存键都必须包含租户信息（避免串数据）；
- 任何导出/分享都要有显式授权与审计。[68]

### 4) 审计：把背锅变成可追责
审计日志是事故复盘的事实源，也是很多企业客户付费的理由之一。[68]

#### 审计事件规范

| 字段 | 说明 |
| --- | --- |
| who | user_id / service_id |
| when | timestamp |
| where | request_id / trace_id / ip（视合规） |
| what | resource_type + resource_id |
| action | read/write/admin/… |
| result | success/fail + reason |
| context | tenant_id、权限决策摘要 |
| payload_summary | 变更摘要（脱敏后，避免写入敏感字段） |
| diff_summary | 关键字段差分（可选，脱敏/哈希） |

建议你先列必须审计的事件，再实现功能：登录、权限变更、导出/删除、计费相关操作、知识库变更等。[68]

!!! note "如何使用审计事件表"
    把审计页做成“能查、能串、能解释”的工作台，而不是日志堆放处：
    - **表格列**：时间/操作者/动作/资源/结果/trace_id，保证可回放定位。
    - **筛选**：按用户、资源、动作、结果（失败优先）快速收敛问题范围。
    - **详情**：展开后展示权限决策摘要（为什么允许/为什么拒绝），用于复盘与对外解释。

审计页的关键不是有没有日志，而是能不能查、能不能串、能不能解释。你至少需要一张可搜索的事件表：

| 时间 | 操作者 | 动作 | 资源 | 结果 | trace_id |
| --- | --- | --- | --- | --- | --- |
|  |  |  |  | success/fail + reason |  |

并支持按用户/资源/动作/结果筛选（失败优先），在详情里能展开权限决策摘要（为什么允许/为什么拒绝）。[68]

### 用 ASVS 校准最低门槛（避免自创安全标准）
如果不想凭感觉决定哪些必须做，可以把最低门槛对照 OWASP ASVS 的几类要求：
- 身份与会话：凭证失效、会话撤销与刷新策略是否可验证。[68][69]
- 访问控制：默认拒绝、资源级校验与越权回归是否存在。[68]
- 日志与监控：敏感操作是否有可追溯审计事件，且不泄露敏感信息。[68]

## 审计日志也是产品能力：它在信任上的杠杆很大
很多人把审计当成合规负担，但在 AI 产品里，审计是你建立信任的一条捷径：当系统做了一个重要动作（导出、删除、共享、调用工具、生成敏感内容的拒绝/降级），用户最在意的是有没有证据。审计让你能回答：发生过什么、为什么发生、我能否证明自己没有越界。[68]

对个人产品而言，它还有一个更现实的好处：减少支持成本。当用户问为什么我看不到/为什么突然不能用/为什么扣费了，你能用一条审计事件把对话从情绪拉回事实。

### 5) 回归：把越权当成阻断级失败
权限系统最怕改一处、崩一片。你需要把越权用例写成固定回归集：
- 跨租户读取必须失败；
- 角色降权后访问必须失败；
- 权限变更必须产生审计事件。[68]

## 复现检查清单（本章最低门槛）
- 权限模型一页纸已完成：主体/资源/动作/租户隔离清晰，并能映射到关键 API 与页面入口。[68]
- 越权回归用例阻断发布：跨租户与资源级权限必测，失败即阻断发布；权限变更后必须复跑回归。[68]
- 审计事件规范可查询：关键操作可追溯可查询，字段一致且不泄露敏感信息（含 trace_id 与策略版本）。[68]
- 权限变更可回滚：策略版本化并支持灰度切换；事故时能快速回到上一策略，并留痕可复盘。

## 常见陷阱（失败样本）
1. **现象：** UI 隐藏了按钮，但接口仍然可调用（越权成功）。  
   **根因：** 把前端显示逻辑当成授权；服务端缺少资源级校验与回归用例。[68]  
   **复现：** 用低权限账号/跨租户 token 直接调用资源接口（绕过 UI），观察是否仍能读到/改到资源。  
   **修复：** 授权必须在服务端做：tenant_id 强校验 + 资源级谓词；把越权请求写成阻断级回归集。[68]  
   **回归验证：** 固定回归用例稳定复跑：跨租户/降权后访问/资源级越权全部失败，并记录一致的拒绝原因。

2. **现象：** 权限改一次，线上就出现大量无法访问或权限漂移，支持成本暴涨。  
   **根因：** 权限模型缺少迁移策略与兼容窗口；策略变更没有灰度与回滚。  
   **复现：** 推出新角色或调整动作集合后，旧数据/旧邀请/旧成员关系无法解释地变成拒绝或误授权。  
   **修复：** 权限策略版本化：新旧策略并行一段窗口；按租户/比例灰度切换；保留一键回滚路径。  
   **回归验证：** 灰度期间关键指标稳定（拒绝率、越权率、支持工单量）；出现异常能快速回退到上一策略版本并恢复口径。

3. **现象：** 出了事故无法追责，只能猜；对外也解释不清为什么允许/为什么拒绝。  
   **根因：** 审计字段缺失或不一致，无法串起链路；缺少 `trace_id` 与策略版本。[68]  
   **复现：** 随机抽一条敏感操作（导出/删除/权限变更），尝试回答“谁做的/做了什么/对哪个资源/结果与原因/当时的策略版本”。答不上即命中。  
   **修复：** 先统一审计事件规范（字段与脱敏规则）；把审计写成硬门槛：缺审计视为未完成。[68]  
   **回归验证：** 对固定敏感操作回归用例，审计事件可查询且字段齐全（含 `trace_id`、`reason`、`policy_version`），并能串起整条链路。

## 交付物清单与验收标准
- 权限模型说明与变更策略（含租户隔离）。[68]
- 审计事件规范与查询方式（能快速定位一条关键操作）。[68]
- 越权回归集（固定攻击用例），回归不过不发布。[68]

## 下一章
用户模块决定谁能做什么。下一章把商业闭环落到系统：订阅、计费、账本、对账与风控。见：[12-billing.md](12-billing.md)。

## 参考
详见本书统一参考文献列表：[references.md](references.md)。
