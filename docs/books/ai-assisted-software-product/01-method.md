# 第 1 章：全流程方法论与 AI 工作台
![第 1 章封面](../../assets/chapter_01_header_1766035335903.png)

> AI 降低了实现的门槛，也把你制造“垃圾代码”的效率提速了十倍。本章不谈工具推荐，只谈一套保命系统：用证据做决策，用门禁做裁决，用回滚治理不确定性。[4][5]

在单人开发模式下，最大的风险不是写不出代码，而是陷入“高速空转”：一周生成了三个月都修不完的碎片功能，或者上线了一个没人用的系统。如果你还是抱着“想到什么就让 AI 写什么”的心态，AI 只会放大你的思维混乱。

本章的任务，是把你的开发过程重构为一条**个人可执行的产品工程流水线（可裁决规则集）**。我们会规定每一步交付什么、做到什么程度才算完、何时必须止损、出问题怎么一键回滚。

后续所有章节，都是这套规则在具体环节（需求、开发、运维）的战术展开。

## 1.1 章节定位：治好你的“松鼠症”
单人开发的核心死因通常有三个：
1.  **伪需求精装修**：把一个根本不成立的需求，用 AI 做得花里胡哨。
2.  **系统脆如纸**：没有测试，没有监控，代码量激增后，改一个 bug 引入两个 bug。
3.  **治理全靠猜**：模型效果波动了？不知道。用户流失了？不知道。全是黑盒。

我们需要把“从 0 到 1”变成一条带门禁的流水线。

**你将获得什么：**
*   **端到端管线图**：清晰的输入输出标准，治好“不知道下一步干嘛”。
*   **AI 工作台规范**：一套可复制的 Prompt 骨架与证据留档机制，明确什么归 AI 做，什么必须你签字。
*   **铁的纪律**：无证据不优化，无回归不上线，无回滚不发布。[5][6]

## 1.2 方法论核心：三层闭环（工程裁决系统）

全书的逻辑建立在三个嵌套的“工程闭环”之上。这不再是管理学的口号，而是拦在你代码仓库前的**硬门禁**。

![图 1-1：三层闭环（价值/交付/治理）示意](../../assets/figure_01_1_1765970807636.png)

### 第一层：价值闭环 (Value) —— 准入与止损
*   **输入**：未验证的假设、ROI 估算。
*   **动作**：建立**证据链 (Evidence Chain)**。在 [第 2 章：需求挖掘](02-discovery.md) 中，我们会要求你先写出“反例假设”：如果证据不足，立刻杀掉项目，回退你的精力投入。
*   **门禁（止损门）**：7 天内拿不到 3 个真实的正面反馈（或等效证据），视为项目失败。
*   **产物**：决策卡 (Decision Card) + 归档证据。

### 第二层：交付闭环 (Delivery) —— 契约与回归
*   **输入**：已通过价值准入的需求范围。
*   **动作**：将 PRD 转化为**可执行契约 (Executable Contract)**。在 [第 3 章：PRD 书写](03-prd.md) 和 [第 7 章：工程化](07-engineering.md) 中，我们会要求每一行代码必须关联一个测试用例。
*   **门禁（准入门）**：主流程自动化回归通过率 100%，异常流覆盖率 > 80%。
*   **产物**：变更卡片 (Change Card) + 自动化回归报告。

### 第三层：治理闭环 (Governance) —— 守门与回滚
*   **输入**：线上流量、生产日志。
*   **动作**：建立**守门指标 (Guardrail Metrics)**。当 AI 的准确率、成本或延迟突破阈值时，触发**一键回滚**（见 [第 17 章](17-deployment.md) 和 [第 20 章](20-governance.md)）。
*   **门禁（基线门）**：主指标提升的同时，守门指标（如 P95 延迟）退化不得超过 5%。
*   **产物**：风险登记册 + 自动回滚脚本。

### 方法论总结：三层门禁表

下表是你必须严格执行的“工程法律”：

| 闭环层级 | 最小工件（Executable） | 核心门禁 (Gate) | 失败判定 / 回滚动作 |
| :--- | :--- | :--- | :--- |
| **价值 (Value)** | 证据链 (Evidence) | 7 天验证期，ROI > 基线 | 证据收集失败 → **立即终止项目** |
| **交付 (Delivery)** | PRD 契约 + 单元测试 | 关键路径 100% 覆盖 | 任何测试失败 → **禁止合并代码 (Git Pre-commit)** |
| **治理 (Governance)** | 守门指标 + 回滚预案 | 指标波动 < 阈值 | 守门指标触碰红线 → **一键回滚版本/配置** |

---

## 1.3 实战路径：全书导航

本书建议的“练级”路径如下。请注意，每个阶段的结束都必须产生对应的**闭环产物**：

1.  **想清楚（价值层）**：[方法论 (01)](01-method.md) → [需求挖掘 (02)](02-discovery.md) → [PRD 契约 (03)](03-prd.md) → [原型断点 (04)](04-prototype.md) → [验证闭环 (05)](05-validation.md)
2.  **造出来（交付层）**：[UI 资产化 (06)](06-ui.md) → [工程化门禁 (07)](07-engineering.md) → [前端不确定性 (08)](08-frontend.md) → [后端受控底座 (09)](09-backend.md) → [Agent & RAG (10)](10-agent-rag.md)
3.  **卖出去（业务层）**：[用户模块 (11)](11-user.md) → [计费与止损 (12)](12-billing.md)
4.  **活下去（治理层）**：[数据资产化 (13)](13-data.md) → [预训练与微调 (14/15)](14-pretrain.md) → [推理优化 (16)](16-inference.md) → [受控部署 (17)](17-deployment.md) → [评测体系 (18)](18-evaluation.md) → [持续迭代 (19)](19-iteration.md) → [合规与治理 (20)](20-governance.md)

---

## 1.4 AI 工作台：从“对话”到“资产”

不要把 AI 当作聊天机器人，把它当作一个**受控的编译器**。

### 1.4.1 核心原则
1.  **原则一：Prompt 即代码**。所有的 Prompt 必须进行版本管理（Git），严禁在网页对话框中手动调参后直接上线。
2.  **原则二：输出必须结构化**。强制 AI 输出 JSON、Markdown 或特定的格式。只有结构化的输出，才能接入[第 7 章](07-engineering.md)的自动化流程。
3.  **原则三：先判后做**。在让 AI 写代码前，先让它生成“验收测试用例”。

### 1.4.2 结构化提示词骨架 (System Prompt Template)

```markdown
# Role: <专业角色，如：高级 TypeScript 架构师>
# Context: <项目路径、技术栈（React 18, Vite）、已有的 API 定义>
# Task: <精确描述要完成的任务>

## Constraints
- 性能要求：<如：Bundle Size 不得增加 5kb>
- 风格约束：<如：使用原子化 CSS，严禁 Inline Style>
- 禁止事项：<如：不要使用 Any 类型>

## Execution Protocol (执行协议)
1. 分析当前代码逻辑。
2. 生成对应的 `vitest` 测试用例。
3. 修改代码以通过测试。
4. 输出格式：[Git Diff]

## Gate (门禁标准)
- [ ] 代码通过 Lint 检查。
- [ ] 存量功能回归测试 100% 通过。
- [ ] 导出报告为 JSON 格式。
```

## 1.5 最小可执行示例：用脚本驱动门禁

我们来看一个如何将“文本质量”变成“工程门禁”的例子。

**场景**：你需要检查 AI 生成的 PRD 文档是否包含了必要的“回退动作”。

```bash
# 脚本：gate_check.sh
# 使用本地 LLM 或 API 接口作为“法庭审判员”

PRD_CONTENT=$(cat docs/prd_v1.md)

# 让 AI 作为评判官
RESULT=$(cat <<EOF | <LLM_CLI>
任务：审查 PRD 文档。
输入内容：$PRD_CONTENT
标准：必须包含'回退动作'章节且不少于 50 字。
输出格式：JSON { \"passed\": boolean, \"reason\": string }
EOF
)

# 解析结果并裁决
PASSED=$(echo $RESULT | jq '.passed')

if [ "$PASSED" == "true" ]; then
  echo "✅ PRD 通过门禁，允许进入开发阶段。"
  exit 0
else
  echo "❌ PRD 缺少有效回退操作，门禁被拦截。原因：$(echo $RESULT | jq '.reason')"
  exit 1
fi
```

这就是**治理闭环**的雏形：在人介入之前，先用机器进行“自动化审判”。

---

## 1.6 两份工程卡片模板

### 模板 1：变更卡片 (Change Card) —— 必填
每次 Git Commit 前，请确保你的 `commit message` 或附带的 `CHANGELOG` 回答了以下问题：

```markdown
# [CHANGE-ID] 变更标题

## 1. 证据 (Evidence)
- 需求来源：<用户反馈 / 评测回归失败>
- 证据数据：<具体的日志、监控、截图链接或评分结果>

## 2. 契约 (Contract)
- 修改范围：<主要修改的文件路径>
- 验收命令：`npm run test:id`
- 异常路径：已处理网络超时、限流与 500 报错。

## 3. 回退 (Rollback)
- 守门指标：P99 延迟 < 500ms
- 回退动作：`git revert HEAD` 或 `sh scripts/rollback.sh`
```

### 模板 2：管线准入表 (Pipeline Admittance)

| 节点 | 准入物 (Ingredient) | 裁决器 (Judge) | 准出标志 (Outcome) |
| :--- | :--- | :--- | :--- |
| **调研** | 想法 + 证据 | 价值闭环 (7天验证) | 决策卡 (Go/No-go) |
| **设计** | 决策卡 | PRD 契约门禁 | 可交付需求列表 |
| **开发** | 需求列表 | 自动化测试门禁 | 通过测试的 Patch |
| **运维** | Patch | 守门指标门禁 | 线上稳定版本 |

---

## 1.7 复现与自检
读完本章，你的项目目录里应该多出以下“工程资产”：
*   [ ] **`templates/change_card.md`**：上面的变更卡片模板。
*   [ ] **`scripts/gate_check.sh`**：一个可执行的、基于 LLM 的文档/代码审查脚本。
*   [ ] **`README.md` 中的管线图**：画出属于你的“价值 -> 交付 -> 治理”数据流向。

## 常见陷阱
1.  **只有代码，没有证据**：翻看你最近的 3 次 commit，如果找不到“为什么做这个”的证据关联，你就在梦游。
2.  **指标虚荣**：优化了“模型准确率”，却导致“推理成本”飙升 5 倍。这就是没有设置**守门指标**（Cost Guardrail）的后果。
3.  **无法回滚**：上线后发现炸了，手忙脚乱地在线修复，而不是一键回退。这是运维事故的“预备役”。

**下一章预告**：
也就是价值闭环的第一步 —— 怎么确认你的想法不是自嗨？请看 [第 2 章：需求挖掘](02-discovery.md)。
