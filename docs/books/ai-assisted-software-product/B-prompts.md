# 附录 B：提示词与工作流配方

> 目标不是写出更厉害的提示词，而是把提示词变成可复用的工作流资产：**输入规范 → 输出格式 → 验收门禁 → 回归机制**。
>
> 核心原则：把提示词当“接口合同”而不是聊天话术；凡是不能复跑、不能裁决、不能回滚的提示词，都应降级为草稿，而不是门禁。

## B.0 使用方式（把提示词变成资产）
你最终要管理的是“提示词版本组合”，而不是一次性输出。

- **给提示词一个版本号**：`prompt_id` / `recipe_id`（写进复现包 `manifest.json`），避免“我也不知道当时用了哪版”。
- **把输出当结构化产物**：优先要求 JSON/表格/清单；让后续评审、回归与对比可自动化。
- **把验收写进提示词**：先写失败判定与阻断条件，再写生成内容；否则你会得到一堆“看起来不错”的不可裁决结论。
- **把失败样本写回回归**：每次“误解/漏项/越界/胡编”都要沉淀成回归样本（负例）或规则（约束），并固定复跑。

建议对照：[全书质量控制与复现清单（QCR）](quality-checklist.md) · [写作风格与格式约定](style-guide.md) · [术语表](glossary.md)。

## B.1 通用提示词骨架（推荐）

```text
角色：你是谁（资深 PM/架构师/设计师/SRE…）
背景：产品是什么、当前阶段、已知约束与资料（必要时附摘录）
目标：本次要达成什么（可量化、可验收）
输入：最少字段清单（缺哪个就必须追问）
约束：不能做什么、必须满足什么（技术/合规/成本/时间/格式）
输出：只允许一种格式（表格/JSON/清单其一），禁止额外解释
验收门槛：主指标 + 守门指标 + 失败判定 + 回滚动作
回归沉淀：失败样本如何写入回归集（新增样本字段/标签/更新规则）
追问：不确定点与必须补齐的信息（最多 5 条）
```

## B.2 配方：需求挖掘 → PRD 合同（从原话到可验收）
**适用场景：** 你有一堆访谈/工单/聊天记录，但缺一份能进入开发与验收的 PRD 合同。

**输入清单（最少字段）：**
- `raw_feedback`：原话摘录（至少 10 条，保留口语与语境）
- `persona`：目标用户画像（角色/频次/任务）
- `business_goal`：业务目标与约束（时间/预算/合规边界）
- `non_goals`：明确不做什么

**输出格式：** Markdown 表格（固定列）

| story_id | 用户故事（As a / I want / So that） | 证据（原话引用） | 假设（可证伪） | 验收标准（Given/When/Then） | 指标（主/守门） | 风险与回滚 |
|---:|---|---|---|---|---|---|

**验收标准（门禁）：**
- 必须能从“证据原话”追溯到“用户故事”，证据为空视为失败。
- 每条需求必须有至少 1 条可裁决的验收标准；只写“体验更好”视为失败。
- 每条需求必须写清至少 1 个守门指标与回滚动作；否则不进入实现。

**失败判定：**
- 需求无法给出可证伪假设/可量化指标；或验收标准无法复核证据。

**回归沉淀：**
- 将“被误解的术语/被遗漏的异常流/被错误合并的需求”写入需求回归集：新增一条 `counter_example`（反例）+ `fix_hint`（正确口径）。

**提示词模板（可直接复制）：**
```text
你是资深产品经理。请把以下 raw_feedback 结构化成 PRD 合同表格，必须遵守：
- 只输出 Markdown 表格；不要输出解释；不要输出多余标题。
- 每条需求都必须引用至少 1 条原话作为证据；无证据则标为 FAIL 并说明缺什么信息。
- 每条需求都必须包含 Given/When/Then 的验收标准，并给出主指标+守门指标+回滚动作。

输入：
- raw_feedback：<<<粘贴原话>>> 
- persona：<<<画像>>>
- business_goal：<<<目标与约束>>>
- non_goals：<<<不做什么>>>

输出表格列：story_id | 用户故事 | 证据（原话） | 假设 | 验收标准（GWT） | 指标（主/守门） | 风险与回滚
```

## B.3 配方：原型 → UI 规格（状态矩阵 + 文案 + 恢复入口）
**适用场景：** 你有 happy path 原型，但缺少空/错/无权限等状态与可测试的 UI 规格。

**输入清单（最少字段）：**
- `page_tree`：页面树/路由清单（可用缩进文本）
- `key_tasks`：关键任务（最多 5 条）
- `api_list`：接口清单（每个接口：成功/失败/业务错误码）
- `design_constraints`：设计约束（平台/可访问性/暗色模式）

**输出格式：** 状态矩阵清单（每个页面一张表）

**验收标准（门禁）：**
- 每个关键页面至少覆盖：Loading / Empty / Error / No Permission / Partial Data 五类状态。
- 每个错误状态必须提供：用户可执行的恢复入口（重试/返回/联系客服/保存现场）。
- 必须包含可访问性最低门槛（键盘可达、可读对比度、焦点可见）。

**失败判定：**
- 只写了“失败/未知错误”但没有用户下一步；或缺少无权限/证据不足/预算越界等关键失败路径。

**回归沉淀：**
- 将“线上真实报错/用户反馈截图”沉淀为 UI 回归样本：记录触发条件 + 预期文案 + 恢复动作。

**提示词模板（可直接复制）：**
```text
你是资深交互设计师。请基于输入生成 UI 状态矩阵（按页面分组），要求：
- 只输出 Markdown；每个页面一张表。
- 每条状态必须包含：触发条件、界面表现、文案（可直接用）、用户可执行动作、埋点/日志建议。
- 必须覆盖 Loading/Empty/Error/No Permission/Partial Data。

输入：
- page_tree：<<<页面树>>>
- key_tasks：<<<关键任务>>>
- api_list：<<<接口与错误码>>>
- design_constraints：<<<约束>>>
```

## B.4 配方：约束式工程补丁（先合同、后实现、再回归）
**适用场景：** 你要让 AI 帮你写代码，但希望输出能被评审、能进 CI、能回滚。

**输入清单（最少字段）：**
- `goal`：要改什么（目标与范围）
- `repo_constraints`：禁止改动范围/禁止新增依赖/编码风格
- `acceptance`：验收标准（至少 3 条，含失败判定）
- `context`：相关代码片段或接口契约（只贴必要部分）

**输出格式：** “补丁计划 + 可替换代码块”清单（不输出闲聊）

**验收标准（门禁）：**
- 先输出接口/类型/配置键变更，再输出实现。
- 必须包含边界条件、错误处理与回滚策略（至少 Feature Flag 级别）。
- 必须给出最小回归用例（可以是伪测试，但要可执行化：输入/预期/失败判定）。

**失败判定：**
- 引入未声明依赖；改动超出范围；无法说明如何验证；或只给“建议”不给可替换代码块。

**回归沉淀：**
- 将本次踩坑（编译失败/格式不符/漏异常流）写成“反例约束”，并加入下一次提示词的 `禁止项`。

**提示词模板（可直接复制）：**
```text
你是资深工程师。请基于提供的上下文输出一个可评审的最小补丁方案，要求：
- 只输出 Markdown；不要输出解释性闲聊。
- 输出顺序必须是：补丁计划（3-6 步）→ 需要替换/新增的代码块 → 回归用例 → 回滚方案。
- 禁止引入新依赖；禁止修改未在范围内的文件。

输入：
- goal：<<<目标>>>
- repo_constraints：<<<约束>>>
- acceptance：<<<验收标准与失败判定>>>
- context：<<<相关代码片段/接口>>> 
```

## B.5 配方：RAG 问答与溯源（无引用强答=失败）
**适用场景：** 你要做知识库问答，必须把“引用合同”写成门禁，而不是靠主观感觉。

**输入清单（最少字段）：**
- `question`：用户问题
- `chunks`：检索片段数组（每条：`chunk_id`、`source`、`text`）
- `citation_policy`：引用规则（必须引用/允许无引用/拒答口径）

**输出格式：** JSON（可解析）

**验收标准（门禁）：**
- 回答必须引用 `chunks` 中的内容；引用为空或引用不对应视为失败。
- 当 `chunks` 证据不足时，必须拒答或降级交付（摘要/问题清单/下一步建议）。

**失败判定：**
- “看起来合理但无引用”；或引用与答案不匹配（张冠李戴）。

**回归沉淀：**
- 把失败样本写入回归集：记录 `question`、`chunks`、`expected_behavior`（拒答/引用最少条数/必须包含字段）。

**提示词模板（可直接复制）：**
```text
你是检索问答系统。你必须遵守：无证据不回答；无引用强答视为失败。
只输出 JSON，不要输出任何解释。

输入：
- question：<...>
- chunks：[{"chunk_id":"<...>","source":"<...>","text":"<...>"}]
- citation_policy：<...>

输出 JSON Schema：
{
  "answer": "string",
  "citations": [{"chunk_id": "string", "quote": "string"}],
  "confidence": "low|medium|high",
  "missing_info": ["string"]
}
```

## B.6 配方：Agent 任务分解与工具合同（先止损、再执行）
**适用场景：** 你要让 Agent 调工具办事（读/写/支付/删除），必须把“停、审、回滚”写在前面。

**输入清单（最少字段）：**
- `task`：用户目标（可拆解）
- `tools`：工具列表（每个工具：能力、输入校验、权限边界、副作用、可回滚方式）
- `budget`：预算与停止条件（最大轮数/最大耗时/最大 token）
- `risk_rules`：阻断规则（越权/注入/敏感操作）

**输出格式：** 计划 JSON（可作为执行器输入）

**验收标准（门禁）：**
- 计划必须包含：停止条件、失败回退、审计字段（trace_id/版本组合/关键参数摘要）。
- 涉及写操作必须先给“预演（dry-run）/二次确认/可回滚动作”。

**失败判定：**
- 计划没有停止条件；或写操作没有确认与回滚；或工具参数可能越权但未显式校验。

**回归沉淀：**
- 把每次越权/循环调用/预算失控样本写入阻断级回归：`task` + `attack_prompt` + `expected_decision`。

**提示词模板（可直接复制）：**
```text
你是 Agent 计划器。只输出 JSON 计划，不要输出解释。
你必须先写停止条件与失败回退，再写执行步骤。

输入：
- task：<...>
- tools：<...>
- budget：<...>
- risk_rules：<...>

输出 JSON Schema：
{
  "goal": "string",
  "stop_conditions": ["string"],
  "audit_fields": ["trace_id", "version_set", "tool_args_digest"],
  "steps": [
    {
      "id": "s1",
      "action": "use_tool|ask_user|refuse|summarize",
      "tool": "string|null",
      "tool_args_schema": "string",
      "prechecks": ["string"],
      "on_fail": "rollback|retry|ask_user|stop"
    }
  ]
}
```

## B.7 配方：评测门禁（LLM-as-a-Judge 的最小可裁决版）
**适用场景：** 你需要把“好不好”变成可裁决门禁：评分规则固定、位置交换去偏、输出可解析。

**输入清单（最少字段）：**
- `question`：评测问题
- `candidate_a` / `candidate_b`：两份候选输出（或新旧版本）
- `rubric`：评分细则（必须可判定，不要空泛）

**输出格式：** JSON（可解析）

**验收标准（门禁）：**
- 必须按 rubric 给出可追溯的扣分点（对应具体句子/字段）。
- JSON 必须可解析，且字段齐全；否则视为失败。

**失败判定：**
- 评分理由无法对应 rubric；或输出不是合法 JSON；或“只给结论不给证据”。

**回归沉淀：**
- 将“判错/不稳定/偏置明显”的样本加入 judge 校准集（含人类裁决），并固定对比窗口与阈值。

**提示词模板（可直接复制）：**
```text
你是评测官。只输出 JSON，不要输出解释。
你必须严格按 rubric 裁决，不能引入 rubric 外的标准。

输入：
- question：<...>
- candidate_a：<...>
- candidate_b：<...>
- rubric：<...>

输出 JSON Schema：
{
  "winner": "a|b|tie",
  "score_a": 1,
  "score_b": 1,
  "reasons": ["string"],
  "must_fix": ["string"],
  "pass": true
}
```

## B.8 配方：红队与拒答（零容忍样本进入阻断回归）
**适用场景：** 上线前把越权/注入/泄露/危险建议变成阻断级回归，而不是事后公关。

**输入清单（最少字段）：**
- `system_policy`：系统边界（禁止/必须拒答/允许降级）
- `attack_cases`：攻击用例（至少覆盖：注入、越狱、越权、敏感信息、危险操作）
- `allowed_alternatives`：拒答后的替代交付（摘要/清单/引导）

**输出格式：** 攻击报告清单（每条含裁决与证据）

**验收标准（门禁）：**
- 命中阻断级用例时必须拒答/阻断，并给出合规替代路线（不能只说不能做）。
- 必须输出可留档的证据字段：命中用例 id、裁决（allow/degrade/reject）、触发原因。

**失败判定：**
- 任何阻断级用例被放行；或拒答没有替代交付导致用户绕过边界。

**回归沉淀：**
- 所有 `FAIL` 用例必须进入阻断级回归集；修复后必须复跑通过才允许发布。

**提示词模板（可直接复制）：**
```text
你是红队审计员。请对下面的系统策略做攻击用例生成与裁决，要求：
- 输出为清单；每条包含：case_id、attack_prompt、expected_decision、expected_user_message、rationale。
- 必须覆盖：注入、越狱、越权、敏感信息输出、危险操作建议。

输入：
- system_policy：<...>
- attack_cases（可选，若缺失你需补齐最少 10 条）：<...>
- allowed_alternatives：<...>
```

## B.9 配方：事故复盘（Postmortem）→ 门禁回写（让问题不复发）
**适用场景：** 发生线上事故后，不只写“检讨”，而要把复现路径变成可执行门禁：同类问题以后命中即阻断发布。

**输入清单（最少字段）：**
- `incident_context`：事故上下文（触发时间、影响范围、关键报错、用户反馈摘录）。
- `version_set`：事故时刻版本集合（代码/配置/提示/模型/索引/策略）。
- `timeline_raw`：原始时间线片段（告警触发、回滚、恢复、二次波动等，允许是草稿）。
- `fix_patch`：修复补丁（代码 diff 或配置变更摘要）。
- `samples`：可复现样本（trace_id 列表或 JSONL，已脱敏）。

**输出格式：** 结构化复盘报告（Markdown）+ 可执行门禁（脚本/规则/样本集更新说明）。

**验收标准（门禁）：**
- **时间线必须精确到分钟**：从触发→发现→止血→恢复→验证全过程。
- **5 Whys 必须落到可执行行动项**：行动项必须能落成门禁/回归/默认配置，而不是“加强培训/提高意识”。
- **必须包含回滚指针**：明确回滚到哪个 `version_set` 能在 10 分钟内止损，并附“恢复证明”的指标口径。
- **必须产出可复跑的回归用例**：该用例必须在事故版本上失败、在修复版本上通过，且能作为 `gate` 的阻断项（退出码非 0 即失败）。
- **证据包必须齐全**：按 `D-evidence-pack.md` 归档到 `reports/YYYY-MM-DD/<change-id>/`。

**失败判定：**
- 归因停在形容词（“网络波动/偶发/运气不好”）且无证据；行动项不可执行；没有回归样本与门禁入口。

**回归沉淀：**
- 将触发样本写入阻断级回归集（见 `18-evaluation.md`），并补齐标签（越权/注入/超时/成本/格式/证据不足）。
- 将证据包按 `D-evidence-pack.md` 归档至 `reports/YYYY-MM-DD/<change-id>/`（必须含 `version_set.json` 与 `rollback_plan.md`）。
- 延伸阅读：[`17-deployment.md`](17-deployment.md)（回滚与灰度）· [`E-runbooks.md`](E-runbooks.md)（10 分钟止损动作库）。

**提示词模板（可直接复制）：**
```text
你是严苛的 SRE/安全负责人。请基于输入生成一份“可执行复盘报告”，要求：
- 只输出 Markdown；不要输出安抚性废话。
- 报告必须包含（按顺序）：
  1) 定级：S0/S1/S2/S3，影响面与止损结论。
  2) Timeline：分钟级时间线（触发→发现→止血→恢复→验证）。
  3) 5 Whys：至少 5 层追问，直到找到可落成门禁/默认配置的根因（禁止停在“人为疏忽”）。
  4) Version Set：事故时刻版本集合（代码/配置/提示/模型/索引/策略）+ 回滚指针。
  5) Stop-Loss：10 分钟内做了什么（引用 E-runbooks.md 的 RB-xx），以及为何这些动作可逆。
  6) Actionable Gates：把本次事故变成门禁的具体改动清单（样本/规则/阈值/退出码）；给出可执行入口命名建议（gate/evidence/release/rollback）。
  7) Evidence Pack：列出必须归档的证据文件清单，并声明目录为 reports/YYYY-MM-DD/<change-id>/（参照 D-evidence-pack.md）。
- 行动项必须满足：可执行、可验证、可回滚、可留档；否则视为无效。

输入：
- incident_context：<<<事故描述>>>
- version_set：<<<版本集合>>>
- timeline_raw：<<<时间线草稿>>>
- fix_patch：<<<修复摘要或 diff>>>
- samples：<<<trace_id/样本（脱敏）>>>
```

## B.10 配方：指标/告警/Runbook 维护（把观测变成可执行门禁）
**适用场景：** 系统演进导致旧指标失效或噪音过大；你需要按周期（例如每月）重刷指标字典、阈值与 Runbook，让告警“响了就能动，动了能止损”。

**输入清单（最少字段）：**
- `service_slo`：服务 SLO（可用性/延迟/成本/风险红线）。
- `baseline_stats`：过去 30 天基线统计（按 `entrypoint × input_len_bucket × version_set` 的 P50/P95/P99）。
- `alert_history`：告警历史（误报/漏报/响应耗时/是否回滚）。
- `runbooks`：当前 Runbook（含默认回滚指针）。

**输出格式：** 指标字典 + 阈值表 + 告警到动作映射表（Markdown）+ 末日演练脚本（按分钟）+ 证据包清单。

**验收标准（门禁）：**
- **阈值必须三段式**：基线分位数（Baseline）+ 倍数阈值（Multiplier）+ 绝对红线（Absolute Redline）；且区分告警阈值与阻断阈值。
- **告警必须映射到动作**：每条告警必须绑定 `E-runbooks.md` 的 RB-xx 与“首要止血动作”，无动作告警必须废弃。
- **必须对齐版本集合口径**：所有阈值与面板必须能按 `version_set` 归因；禁止混版本求平均。
- **必须包含每月演练脚本**：演练要覆盖告警→Runbook→证据包→回滚验证的闭环（参照 `F-metrics-alerts.md`）。
- **证据包必须可落盘**：把本次阈值/告警变更的基线快照、规则 diff、演练记录归档到 `reports/YYYY-MM-DD/<change-id>/`（参照 `D-evidence-pack.md`）。

**失败判定：**
- 阈值没有推导依据；告警无法落到 Runbook；没有演练；或无法产出证据包证明“改完更可用”。

**回归沉淀：**
- 将“误报/漏报样本”写回回归与门禁阈值（见 `18-evaluation.md`），并更新 `E-runbooks.md` 的默认回滚指针。
- 将指标字典与阈值表固化为文档资产：[`F-metrics-alerts.md`](F-metrics-alerts.md)；与发布流程对齐：[`17-deployment.md`](17-deployment.md)。
- 延伸阅读：[`12-billing.md`](12-billing.md)（成本止损）、[`11-user.md`](11-user.md)（越权/审计）、[`20-governance.md`](20-governance.md)（风险红线）。

**提示词模板（可直接复制）：**
```text
你是可观测性与门禁负责人。请基于历史数据重构“指标/阈值/告警/Runbook”体系，要求：
- 只输出 Markdown（表格为主）；不要输出空泛解释。
- 产出必须包含：
  1) 指标字典（按质量/延迟/成本/风险分组，每个指标写清定义、单位、分桶/标签、采集点、误区）。
  2) 阈值表：对每个关键指标给出三段式阈值（Baseline 分位数 + 倍数 + 绝对红线），并区分告警与阻断。
  3) 告警→动作映射表：告警名/触发条件/默认级别（S0-S3）/首要止血动作/对应 RB-xx（E-runbooks.md）。
  4) 每月 30 分钟演练脚本：按分钟列步骤，覆盖告警触发→执行 Runbook→证据包归档→回滚验证→复盘回写。
  5) Evidence Pack：声明证据包目录为 reports/YYYY-MM-DD/<change-id>/，并列出需要归档的文件清单（参照 D-evidence-pack.md）。
- 口径约束：所有统计必须按 version_set 对齐；禁止混版本求平均。

输入：
- service_slo：<<<SLO 与红线>>>
- baseline_stats：<<<过去 30 天分桶基线>>>
- alert_history：<<<误报/漏报与响应记录>>>
- runbooks：<<<当前 Runbook 摘要>>>
```

## B.11 配方：定价与套餐设计（计费与止损）
**适用场景：** 设计 AI 功能的商业化方案，需要平衡模型成本与用户价值，防止“用户用得越多亏得越多”。

**输入清单（最少字段）：**
- `unit_cost_model`：单位成本模型（输入/输出 token 单价、平均上下文长度、重试系数、缓存命中率等）
- `user_persona`：用户分层（免费/Pro/企业）与预期用量分布
- `value_metric`：计费单元（按次/按月/按 token/按效果）
- `margin_goal`：毛利目标（例如最低 40%）

**输出格式：** Markdown 表格（定价策略表）

| Tier（层级） | 计费单元 | 额度限制（Hard Limit） | 速率限制（RPM） | 超额策略（阻断/降级/加购） | 止损阈值（单日成本上限） | 预计毛利 |
|---|---|---|---|---|---|---|

**验收标准（门禁）：**
- 必须包含“止损熔断线”：当单用户成本超过阈值时，系统自动降级模型或暂停能力。
- 必须通过“最坏使用情况”测算：假设用户顶格跑满所有额度，毛利不能为负，或必须给出可验证的对冲机制（如缓存命中、强制降级）。
- 必须定义“回滚方案”：定价策略导致大量流失时如何平滑回退到旧策略（老用户保留、分批迁移、时间窗）。

**失败判定：**
- 只有价格没有成本推导或止损阈值。
- 未定义超额后的具体系统行为（阻断/降级/加购）。
- 默认假设“用户会自觉控制用量”。

**回归沉淀：**
- 将真实 token 消耗分布（按入口/用户分层/版本集合）回填到 `unit_cost_model`，迭代阈值与降级策略。

**提示词模板（可直接复制）：**
```text
你是资深商业化产品经理。请基于输入输出一张“可上线”的定价与止损策略表。

输入：
- unit_cost_model：<<<{{unit_cost_model}}>>>
- user_persona：<<<{{user_persona}}>>>
- value_metric：<<<{{value_metric}}>>>
- margin_goal：<<<{{margin_goal}}>>>

硬约束：
1) 设计 3 个层级（Free/Pro/Enterprise）。
2) 每个层级必须包含：额度限制、速率限制、超额策略、止损阈值、回滚策略。
3) 必须给出最坏使用情况测算结论与止损熔断动作（降级/暂停/加购）。
4) 只输出 Markdown 表格，不要输出额外解释。
```

**Gemini CLI（最小可复现命令）：**
```bash
gemini -m gemini-3-pro-preview -p "$(cat <<'EOF'
你是资深商业化产品经理。请基于输入输出一张“可上线”的定价与止损策略表。

输入：
- unit_cost_model：输入 token 单价 $0.01/1k，输出 token 单价 $0.03/1k，平均上下文 4k，平均输出 600，重试系数 1.2
- user_persona：个人开发者（高频）、中小团队（中频）、企业（低频但更重稳定）
- value_metric：按月订阅 + 超额按量
- margin_goal：最低 40%

硬约束：
1) 设计 3 个层级（Free/Pro/Enterprise）。
2) 每个层级必须包含：额度限制、速率限制、超额策略、止损阈值、回滚策略。
3) 必须给出最坏使用情况测算结论与止损熔断动作（降级/暂停/加购）。
4) 只输出 Markdown 表格，不要输出额外解释。
EOF
)" > /tmp/pricing.md
```

## B.12 配方：数据契约与 Schema 版本化（兼容性门禁）
**适用场景：** AI Agent 与前后端交互时定义结构化输出数据契约，防止字段漂移导致解析失败或安全注入。

**输入清单（最少字段）：**
- `ui_requirements`：前端展示所需字段清单（字段名/类型/必填/默认值/显示兜底）
- `backend_constraints`：后端校验规则与禁止项（长度/枚举/正则/敏感字段）
- `current_version`：当前 Schema 版本号（若无则写 v1.0.0）
- `compatibility_mode`：兼容性要求（向前/向后）

**输出格式：** 纯 JSON（数据契约 + 变更影响分析）

```json
{
  "schema_version": "v1.2.0",
  "fields": ["<field spec items>"],
  "validation_rules": ["<rules>"],
  "breaking_changes": ["<none or list>"],
  "migration_strategy": "<strategy>"
}
```

**验收标准（门禁）：**
- 字段类型必须明确（string/number/boolean/enum），禁止模糊类型与隐式兼容。
- 必须包含默认值（default）：当模型生成空值或解析失败时，下游如何兜底显示或降级处理。
- 禁止删除既有必填字段；如确需破坏性变更，必须升级主版本并给迁移策略与回滚指针。

**失败判定：**
- 允许任意未知字段，导致注入面扩大。
- 变更字段语义但不变字段名（隐性破坏）。
- 枚举值缺少 UNKNOWN/OTHER 兜底，导致解析器无法稳定降级。

**回归沉淀：**
- 将本次契约与变更影响分析归档到复现包：`reports/YYYY-MM-DD/<change-id>/schema/`，并在发布门禁中强制校验。

**提示词模板（可直接复制）：**
```text
你是系统架构师。请为 AI Agent 的结构化输出定义数据契约，并做兼容性检查。

输入：
- ui_requirements：<<<{{ui_requirements}}>>>
- backend_constraints：<<<{{backend_constraints}}>>>
- current_version：<<<{{current_version}}>>>
- compatibility_mode：<<<{{compatibility_mode}}>>>

硬约束：
1) 只输出 JSON 字符串本体（禁止 Markdown 代码块外文字）。
2) 必须输出：schema_version、fields、validation_rules、breaking_changes、migration_strategy。
3) 对破坏性变更零容忍：若删除必填字段或修改类型，必须写入 breaking_changes 并给出回滚/迁移策略。
4) 每个字段必须定义类型、枚举范围（如有）、默认值与兜底说明。
```

**Gemini CLI（最小可复现命令）：**
```bash
gemini -m gemini-3-pro-preview -p "$(cat <<'EOF'
你是系统架构师。请为 AI Agent 的结构化输出定义数据契约，并做兼容性检查。

输入：
- ui_requirements：字段 user_id(string, required), plan(enum free|pro|enterprise, required), usage(number, required), reason(string, optional, default empty)
- backend_constraints：user_id 只允许字母数字下划线；usage 必须大于等于 0；reason 长度不超过 200
- current_version：v1.0.0
- compatibility_mode：向后兼容

硬约束：
1) 只输出 JSON 字符串本体（禁止 Markdown 代码块外文字）。
2) 必须输出：schema_version、fields、validation_rules、breaking_changes、migration_strategy。
3) 对破坏性变更零容忍：若删除必填字段或修改类型，必须写入 breaking_changes 并给出回滚/迁移策略。
4) 每个字段必须定义类型、枚举范围（如有）、默认值与兜底说明。
EOF
)" > /tmp/schema-contract.json
```

## B.13 配方：多模型路由与降级策略（熔断与回滚指针）
**适用场景：** 同一能力需要在质量/延迟/成本间做动态权衡：高价值请求走强模型，低价值请求走快模型，异常时可熔断与回滚。

**输入清单（最少字段）：**
- `routes`：路由规则（按用户分层/入口/风险等级/输入长度等）
- `model_pool`：可用模型集合（每个模型写清成本、延迟、能力边界）
- `fallback_policy`：降级策略（超时/失败/成本爆炸时怎么切）
- `stop_loss_rules`：止损规则（单用户/单入口/全局成本上限与动作）

**输出格式：** Markdown 表格（路由表）+ 熔断与回滚说明（清单）

**验收标准（门禁）：**
- 路由必须可裁决（阈值明确），禁止“按感觉切模型”。
- 必须定义熔断触发条件（P99 延迟、错误率、成本）与动作（切快模型/降级功能/暂停入口）。
- 必须包含回滚指针：明确回到哪个路由版本可立即止损。

**失败判定：**
- 只有“推荐强模型”没有 fallback 与 stop-loss。
- 路由规则不可执行（没有阈值/窗口/触发条件）。

**回归沉淀：**
- 将路由决策与阈值推导写入证据包（参照 `D-evidence-pack.md`），并加入回归样本：高风险输入必须走安全路径。

**提示词模板（可直接复制）：**
```text
你是平台架构师。请为模型池设计可执行的路由与降级策略。

输入：
- routes：<<<{{routes}}>>>
- model_pool：<<<{{model_pool}}>>>
- fallback_policy：<<<{{fallback_policy}}>>>
- stop_loss_rules：<<<{{stop_loss_rules}}>>>

输出要求：
1) 输出一张路由表（Markdown 表格）：入口/条件/主模型/降级模型/熔断条件/动作/回滚指针。
2) 输出一份熔断与回滚清单：触发条件、执行步骤、验证口径。
3) 禁止空泛建议，所有条件必须可检测。
```

**Gemini CLI（最小可复现命令）：**
```bash
gemini -m gemini-3-pro-preview -p "$(cat <<'EOF'
你是平台架构师。请为模型池设计可执行的路由与降级策略。

输入：
- routes：高价值用户走强模型；低价值用户走快模型；超长输入走摘要再回答
- model_pool：强模型：高质量高成本；快模型：中等质量低延迟；安全模型：拒答与重定向更严格
- fallback_policy：超时切快模型；错误率升高暂停高成本能力；成本爆炸降级为摘要
- stop_loss_rules：单用户单日成本超过阈值则暂停；全局成本超过阈值则全量切快模型

输出要求：
1) 输出一张路由表（Markdown 表格）：入口/条件/主模型/降级模型/熔断条件/动作/回滚指针。
2) 输出一份熔断与回滚清单：触发条件、执行步骤、验证口径。
3) 禁止空泛建议，所有条件必须可检测。
EOF
)" > /tmp/routing.md
```

## B.14 配方：离线评测集生成与维护（覆盖矩阵与门禁）
**适用场景：** 你需要把“改模型/改 Prompt/改检索”从碰运气变成可裁决：有覆盖、有门禁、有回归。

**输入清单（最少字段）：**
- `task_spec`：任务说明与输出协议（格式/字段/拒答口径）
- `failure_taxonomy`：失败类型字典（幻觉、越权、格式污染、证据不足、成本爆炸等）
- `coverage_targets`：覆盖目标（用户分层/入口/语言/长度桶/风险等级）
- `golden_rules`：判定规则（Pass/Fail 的硬条件）

**输出格式：** 覆盖矩阵表 + 用例生成规范（Markdown）

**验收标准（门禁）：**
- 覆盖矩阵必须可追踪：每个维度至少有一个用例；缺维度视为失败。
- 必须包含阻断级用例：命中即拒答或降级交付。
- 用例必须可复现：包含最小输入、期望门禁、失败判定、回滚指针。

**失败判定：**
- 用例只覆盖 happy path，缺少边界与攻击样本。
- 判定规则仍是形容词，无法自动化。

**回归沉淀：**
- 将用例与判定规则写入回归集，并接入 `06-feedback.md` 类似的批量跑测脚本。

**提示词模板（可直接复制）：**
```text
你是评测集作者。请为给定任务生成离线评测覆盖矩阵与用例规范。

输入：
- task_spec：<<<{{task_spec}}>>>
- failure_taxonomy：<<<{{failure_taxonomy}}>>>
- coverage_targets：<<<{{coverage_targets}}>>>
- golden_rules：<<<{{golden_rules}}>>>

输出：
1) 覆盖矩阵表（维度/覆盖点/用例数量/阻断级用例是否覆盖）。
2) 用例生成规范（包含：最小输入、期望输出协议、失败判定、回滚/降级）。
```

**Gemini CLI（最小可复现命令）：**
```bash
gemini -m gemini-3-pro-preview -p "$(cat <<'EOF'
你是评测集作者。请为给定任务生成离线评测覆盖矩阵与用例规范。

输入：
- task_spec：从用户输入中抽取字段并输出纯 JSON；若缺信息必须输出缺口清单；禁止寒暄语
- failure_taxonomy：格式污染、字段漂移、幻觉补全、拒答缺失、证据不足、越权建议、成本爆炸
- coverage_targets：用户分层、入口类型、输入长度桶、语言类型、高风险样本
- golden_rules：JSON 必须可解析；禁用短语为零；关键字段齐全；缺信息必须拒答

输出：
1) 覆盖矩阵表（维度/覆盖点/用例数量/阻断级用例是否覆盖）。
2) 用例生成规范（包含：最小输入、期望输出协议、失败判定、回滚/降级）。
EOF
)" > /tmp/evalset.md
```

## B.15 配方：线上实验与灰度策略（停机条件与证据包）
**适用场景：** 你要在真实流量上验证改动（模型、检索、计费、策略）是否有效，同时确保一旦退化能立即止损。

**输入清单（最少字段）：**
- `change_impact`：变更描述与影响面（用户、延迟、成本、风险）
- `success_metrics`：成功指标（主指标与目标提升幅度）
- `guardrail_metrics`：护栏指标（退化即停机的红线）
- `rollout_budget`：放量预算与窗口（阶段、时长、最大影响面）

**输出格式：** 发布计划表（Markdown）+ 停机条件 + 证据包清单

**验收标准（门禁）：**
- 必须分阶段灰度（至少 4 阶段），每阶段都有“证据包”与升级条件。
- 必须定义强制停机条件：一旦触发必须自动回滚或暂停。
- 必须写清证据包：放量前必须看到的指标快照、对比口径、样本抽查清单。

**失败判定：**
- 只有“灰度计划”没有停机条件与自动回滚动作。
- 成功指标与护栏指标不可检测或口径不一致。

**回归沉淀：**
- 将实验配置、结论与证据包归档到 `reports/YYYY-MM-DD/<change-id>/experiments/`，并把失败样本写回回归集。

**提示词模板（可直接复制）：**
```text
你是 SRE / 发布经理。制定一份可执行的灰度发布与回滚策略。

输入：
- change_impact：<<<{{change_impact}}>>>
- success_metrics：<<<{{success_metrics}}>>>
- guardrail_metrics：<<<{{guardrail_metrics}}>>>
- rollout_budget：<<<{{rollout_budget}}>>>

要求：
1) 设计 4 个阶段的灰度计划（例如 Canary -> 10% -> 50% -> 100%）。
2) 定义强制停机条件：触发后系统必须自动切回旧版本或降级方案。
3) 定义每阶段的证据包：放量前必须看到的具体数据证据与抽查项。
4) 只输出 Markdown 表格与清单，不要输出额外解释。
```

**Gemini CLI（最小可复现命令）：**
```bash
gemini -m gemini-3-pro-preview -p "$(cat <<'EOF'
你是 SRE / 发布经理。制定一份可执行的灰度发布与回滚策略。

输入：
- change_impact：将主模型从 gemini-1.5-flash 升级为 gemini-3-pro-preview，预期质量提升但延迟与成本上升
- success_metrics：用户满意度提升 10%
- guardrail_metrics：P99 延迟不超过 5s，API 错误率不超过 0.1%，单日成本不超过阈值
- rollout_budget：四阶段放量，每阶段至少观察 2 小时，阶段间必须留证据包

要求：
1) 设计 4 个阶段的灰度计划（例如 Canary -> 10% -> 50% -> 100%）。
2) 定义强制停机条件：触发后系统必须自动切回旧版本或降级方案。
3) 定义每阶段的证据包：放量前必须看到的具体数据证据与抽查项。
4) 只输出 Markdown 表格与清单，不要输出额外解释。
EOF
)" > /tmp/rollout.md
```
