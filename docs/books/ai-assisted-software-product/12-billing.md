# 第 12 章：付费模块：订阅、计费与风控
![第 12 章封面](../../assets/chapter_12_header_1766035684589.png)

> 计费系统不是把支付接上，而是一份可追溯的合同：谁在何时用掉了什么、应付多少、为什么这么算、出错如何纠正。做对了，它让你能增长；做错了，它让你背锅。[23][5]

AI 产品的计费比传统 SaaS 更敏感：成本与质量强耦合、调用次数随交互波动、异常峰值容易把利润吃光。因此风控与止损不是后补丁，而是计费设计的一部分。[6]

如果你接入银行卡支付，第一原则是让敏感卡数据不要进入你的系统和日志。把支付与卡信息处理交给支付服务商，你自己只处理订单、订阅状态、用量事件与回调，把 PCI 范围尽量压到最小。[23]

但请别自欺欺人：付费合规不是只有 PCI。计费系统里同样有敏感数据：用户身份、账单与用量明细、以及可能含个人信息的输入输出摘要。0→1 阶段你不需要自己造全套税务与隐私引擎，但必须把结构预留出来：币种、税务归属与税率版本、发票/收据号、数据留存与删除策略，否则你迟早在出海、财务审计或用户投诉里返工。

## 章节定位
本章承接用户与权限，把商业闭环落到系统默认属性：定价模型、计量口径、账本与对账、异常处理与风控。它的目标不是让你马上做出完美收费，而是让你从第一天起就能算清账、能对账、能回滚。[23]

## 你将收获什么
- 三种常见定价模型的选择框架：订阅、用量计费、混合计费（以及各自的坑）。
- 一套计量口径 → 账本 → 对账的最小闭环：可重放、可纠错、可追责。[5]
- 一套风控与止损线：异常用量、退款/拒付、成本尖峰都能被系统拦住。[6]

## 三层思考：计费是系统的事实
### 第 1 层：读者目标
你要交付的是一套让自己睡得着的系统：收费可解释、账目可重放、异常可止损。

### 第 2 层：论证链条
计费系统的链条是：

定价模型 → 计量口径 → 账本记录（不可变）→ 对账与结算 → 退款与纠错 → 风控与止损 → 审计与回滚

只要你缺不可变账本与对账，迟早会在争议与退款里崩溃。[23][5]

### 第 3 层：落地与验收
验收不是能扣款，而是：
- 同一笔用量不会重复计费（幂等与去重）；[5]
- 任何账单都能解释与重放（审计与对账）；
- 成本/风险越界时能止损（限额/降级/暂停）。[6]

![图 12-1：计费闭环示意](../../assets/figure_12_1_1765971267577.png)

## 关键流程图（纯文本）：计费闭环（口径→账本→对账→止损）
不依赖图片也能落地：把每个环节的输入/产出/不变量写清楚，你就能做审计、做对账、做纠错。

| 环节 | 输入 | 产出 | 关键不变量 |
| --- | --- | --- | --- |
| 定价与承诺 | plan、price_version | 对外承诺（权益与边界） | 规则版本化，可解释 |
| 计量 | request_id、trace_id | metering_event | 幂等 key、去重 |
| 入账 | metering_event | ledger_event | 不可变，只能冲正/补记 |
| 汇总 | ledger_event | usage_rollup | 可重放、可回算 |
| 出账 | rollup、税规则 | invoice/statement | 币种与税率锁定 |
| 收款与退款 | invoice | payment/refund | 状态机可追溯 |
| 对账 | payment + ledger | 差异清单 | 每一条差异有证据 |
| 争议与纠错 | 用户质疑 | reversal/credit_note | 不改历史，留痕 |
| 止损与降级 | 成本与风险指标 | throttle/degrade/pause | 先止血再复盘 |

## 示例（可复制）：不可变账本 + 冲正（幂等去重）

**目标：** 用最小脚本验证三件事：计量事件幂等、账本只追加、纠错只能用冲正（reversal）。

**前置条件：**
- Python 3 可用

**步骤：**
1. 复制并运行下面脚本：它会模拟一条用量事件入账、重复事件去重、再做一次冲正。
```bash
python3 - <<'PY'
from __future__ import annotations

def append_ledger(ledger: list[dict], event: dict, idempotency_keys: set[str]) -> None:
    key = event["idempotency_key"]
    if key in idempotency_keys:
        return
    idempotency_keys.add(key)
    ledger.append(event)

def total_amount_cents(ledger: list[dict]) -> int:
    return sum(int(e["amount_cents"]) for e in ledger)

ledger: list[dict] = []
idem: set[str] = set()

usage = {
    "event_id": "e_001",
    "idempotency_key": "req_001:metering_v1",
    "type": "usage",
    "amount_cents": 120,
}
append_ledger(ledger, usage, idem)
append_ledger(ledger, usage, idem)  # duplicate, must be ignored

reversal = {
    "event_id": "e_002",
    "idempotency_key": "req_001:reversal_v1",
    "type": "reversal",
    "amount_cents": -120,
    "reverses_event_id": "e_001",
}
append_ledger(ledger, reversal, idem)

assert len(ledger) == 2, "ledger must be append-only (no overwrite)"
assert total_amount_cents(ledger) == 0, "reversal must cancel the original charge"
print("ok")
PY
```
2. 在你的系统里，把 `idempotency_key` 固化为计量事件的合同字段（常用形态：`request_id:metering_version`），并把冲正写成单独事件（不要改旧账单行）。
3. 将“重复回调/重试风暴/冲正后重算”写进对账回归：命中即触发告警或阻断出账。

**验证命令：**
- 上面脚本输出 `ok` 且退出码为 0；在你的工程中，对应对账/出账任务应能复跑并得到同口径结果。

**失败判定：**
- 重复计量没有被去重，或纠错通过改历史而不是冲正；对账无法解释差异来源。

**回滚：**
- 立即停止出账并回滚到上一计量/定价版本（`price_version`/`metering_version` 回退）；用冲正/补记纠正已产生的错误账目，并把触发样本固化进回归与风控门禁。

## 先做选择：你卖的到底是什么
### 定价模型速览

| 模型 | 适合什么 | 最大风险 |
| --- | --- | --- |
| 订阅（按周期） | 价值稳定、可预测 | 用得越多越亏 |
| 用量计费 | 成本与价值可对齐 | 计量与对账复杂 |
| 混合（订阅+用量） | 既要现金流又要扩展 | 规则太多导致争议 |

0→1 的建议：先保证可解释、可止损，再追求精细化定价。你越早建立对账与止损线，越不容易被异常峰值拖垮。[6]

!!! note
    文字版示意：定价页信息结构（不用画图也能交付）
    - 顶部：一句话价值闭环 + 计费单位（订阅周期或用量单位）
    - 中部：分层承诺（每层的产出、上限、护栏：降级/限流/暂停）
    - 透明说明：计量口径、失败/取消是否计费、重试去重规则
    - 控制：预算上限、稳定模式、限流策略、暂停与恢复
    - 底部：FAQ（账单入口、导出明细、争议与退款怎么走）

定价页最常见的灾难不是贵，而是看不懂：用户不知道自己买到的是什么结果、超额会发生什么、怎么控制成本。你可以用一个简单的信息层级把它写清楚：

```text
[一句话价值闭环：用户得到什么结果]

[分层承诺：每一层能做什么 + 会被什么护栏约束]

[透明说明：计量口径/预算/超额后的系统行为（降级/限流/暂停）]

[FAQ：如何计量、失败是否计费、如何查看账单与审计]
```

## 计量口径：先写怎么数，再写多少钱
AI 产品里，计量口径常见有三类：
- 请求次数（简单但容易被滥用）
- 资源单位（例如：处理文档数、导入条数）
- 成本近似（例如：token、工具调用次数、向量检索次数）[6]

关键是：口径必须能被审计与复现，否则你无法解释账单争议。

如果你不知道口径应该细到什么程度，一个实用参照是用量计费的通用工程实践：计量事件、聚合窗口、补写/更正、幂等与去重、以及用户侧可解释的明细与汇总。[75]

### 计量口径卡

| 字段 | 说明 |
| --- | --- |
| 计量单位 | 你数的是什么（次/条/页/token/工具调用） |
| 归属对象 | 归到用户还是租户（tenant） |
| 计量时机 | 什么时候记账（请求开始/完成/成功才记） |
| 去重规则 | 重试、回调重复、幂等如何处理 |
| 例外与豁免 | 哪些情况不计费（失败、系统错误） |
| 展示方式 | 用户如何查看与理解用量 |

### AI 计量单位与边缘情况（最容易引发争议）
AI 产品的计量争议，往往不在单价，而在边界条件：失败算不算、重试算不算、流式中断算不算、工具调用失败算不算。

| 计量单位（例） | 适用能力 | 争议边界 | 0→1 建议口径 |
| --- | --- | --- | --- |
| token_in/token_out | 对话/生成 | 流式中断、超时 | 以完成为主；系统错误豁免；用户主动取消可按部分计 |
| tool_calls | Agent 工具 | 工具失败重试 | 幂等去重；失败原因区分系统/用户；越权阻断不计费 |
| vector_search_calls | RAG 检索 | 重排/多阶段召回 | 把多阶段算进一次请求成本，不让用户背框架细节 |
| documents_ingested | 知识库导入 | 重复导入、更新 | 以去重后新增文档计；更新写入版本并可回滚 |

## 用量与账单的产品呈现：把算账变成用户能理解的语言
计费系统常见的争议，不是出在计算公式，而是出在解释。用户不懂你的 Token、也不关心你的向量检索次数，他只关心两件事：我为什么被扣了这些钱？我能怎么控制它？

因此，用量与账单页面的目标不是展示很多数字，而是让用户能做出下一步行动：
- 预期：我继续用下去会发生什么（是否会触发降级/限流/暂停）？
- 控制：我如何把用量降下来（缩短输入、减少工具、批量任务排队）？
- 追溯：这笔费用对应哪个任务/哪个请求（能回放到证据）？[5]

!!! note
    文字版示意：用量页必须回答的三件事（看得懂 + 能动手）
    - 预期：继续用下去会发生什么（预计账单区间、何时触发护栏）
    - 控制：我能怎么降成本（预算、稳定模式、限流、暂停）
    - 追溯：这笔钱对应哪个请求（可回放到证据）

用量页也不需要复杂，但必须可操作：

```text
[本周期用量进度：已用/剩余] + [预计账单：区间/趋势，不让用户猜]

[费用拆分：按入口/能力/模型/工具调用] + [最费钱路径提示]

[控制开关：预算上限 | 稳定模式 | 限流策略 | 导出明细]（每个开关都说明会牺牲什么体验）
```

建议给用户一个可导出的最小明细（CSV/Parquet 都行），否则争议处理只会靠嘴：

| 字段 | 用途 |
| --- | --- |
| timestamp | 发生时间 |
| tenant_id / user_id | 归属 |
| request_id / trace_id | 证据定位 |
| action | 业务语义 |
| quantity + unit | 计量解释 |
| amount + currency_code | 金额解释 |
| model/tool_calls/token_in/token_out | 成本解释（摘要） |
| status + exemption | 是否计费与原因 |
| price_version | 规则回放 |

## 账本：把事实写成不可变记录
账本的意义是：你永远能回答为什么这笔钱要收/要退。因此账本记录必须：
- 可追溯到一次行为（request_id、user_id、action）；
- 可重放（同一事件重放不会改变总额）；
- 可纠错（用冲正/补记而不是直接改历史）。[5][23]

### 账本事件最小字段

| 字段 | 说明 |
| --- | --- |
| ledger_event_id | 事件唯一标识（用于去重） |
| user_id / tenant_id | 归属 |
| action | 业务语义（例如：chat.complete） |
| quantity | 计量单位数量 |
| unit_price | 单价或计价参数版本 |
| amount | 该事件金额（建议用最小币种单位整数存储） |
| currency_code | 币种（ISO 4217） |
| request_id | 追踪链路 |
| timestamp | 发生时间 |
| status | 记账/冲正/退款等 |
| reversal_of_event_id | 被冲正的原事件（可空） |
| price_version | 当前计价规则版本（便于回放） |
| cost_breakdown | token/tool_calls 等成本摘要（用于解释） |
| exemption | 豁免原因（系统错误/风控阻断等） |

### 冲正与补记：不改历史的纠错方式
冲正不是概念，是你能不能活下来的机制：当发现重复计费、计量口径变更、或争议成立时，你只能追加事件修正，而不是篡改旧账。

最小做法：为每个冲正事件写清它冲正谁，以及为什么冲正。

```text
原事件：ledger_event_id=A，amount=500，currency_code=CNY，status=posted
冲正：  ledger_event_id=B，amount=-500，currency_code=CNY，status=reversal，reversal_of_event_id=A
补记：  ledger_event_id=C，amount=450，currency_code=CNY，status=posted（如需按新口径重算）
```

实现要点：
- 冲正事件必须与原事件同币种；若发生跨币种结算，转换应发生在出账层而非账本层。
- 冲正也要幂等：用 `reversal_of_event_id + reason_code` 做去重 key，避免重复冲正。
- 争议处理要可回放：冲正事件能链接到工单/证据（例如 dispute_id）。

## 对账：让钱与用量一致
对账不是财务专属，它是工程的自救：你要能发现漏记、重复记、异常峰值，并能追溯原因。
它也不是做一次就结束的系统：当你的计量规则、产品入口、模型与工具链不断变化，对账就是你保持口径一致性的最后防线。[75]

0→1 最小对账能力：
- 按天汇总：用量总量、金额总量、失败与退款；
- 抽样复核：随机抽取若干账单，能回放到原始行为；
- 异常告警：用量或金额突增触发止损。[6]

!!! note
    文字版示意：争议处理闭环（不靠嘴，靠证据与回写）
    - 用户发起：选择账单行/时间范围，提交 dispute_id
    - 系统自证：定位到 trace_id，请求摘要、失败原因、豁免命中、计量细则版本
    - 纠错动作：冲正/补记/退款（追加事件，不改历史）
    - 复盘回写：把争议样本与触发条件写回对账规则与风控门禁

账单争议处理也建议写成闭环：用户质疑 → 系统自证 → 纠错留痕 → 复盘回写（否则同样的争议会反复发生）。

```text
用户发起争议（选账单行/时间范围）
  → 系统自证（trace_id + 关键输入摘要 + 结果/失败原因 + 是否命中豁免）
  → 纠错动作（冲正/补记/退款：用事件记录，不改历史）
  → 复盘回写（把争议样本与触发条件写回对账规则与风控门禁）
```

## 出账、发票与税务：让账目成为凭证
账本是事实，账单/发票是凭证。没有出账，你只有一堆事件；一旦要付款、对账、审计或出海，你会发现自己缺的是法律与财务意义上的输出物。

### 0→1 最小对象模型

| 对象 | 作用 | 建议不变量 |
| --- | --- | --- |
| ledger_event | 最小不可变事实 | 只能追加与冲正 |
| invoice/statement | 周期性结算凭证 | 出账后锁定币种与税规则 |
| payment/refund | 收款与退款动作 | 状态机全量留痕 |
| credit_note | 账单层纠错凭证 | 与发票关联，可追溯到原因 |

### 最小出账流程（够用但不丢脸）
1. 关闭周期：确定 period_start/period_end，冻结该周期的聚合口径版本（price_version、tax_version）。
2. 聚合账本：按租户与币种汇总（usage_rollup），并保留可追溯到事件的明细引用。
3. 生成草稿：创建 invoice_draft，允许用户预览费用拆分与证据链接。
4. 税务计算：按用户所在地与税务规则生成税额与税码；把版本写入发票。
5. 付款与最终化：发起 payment_intent；成功则 finalize 为 paid，失败则重试与告警。
6. 纠错与留痕：需要调整时用 credit_note 或冲正 + 重新出账，不要改旧发票内容。

### 发票/账单最小字段（先留结构，后补复杂）

| 字段 | 说明 |
| --- | --- |
| invoice_id | 发票/账单号（对外凭证） |
| tenant_id | 归属 |
| period_start/period_end | 结算周期 |
| currency_code | 结算币种 |
| subtotal/tax/total | 金额（建议最小币种单位整数） |
| tax_jurisdiction | 税务归属（国家/州/省） |
| tax_version | 税率与规则版本 |
| status | draft/open/paid/void |
| issued_at/due_at | 开票与到期 |
| payment_id | 收款关联 |

### 合规底线：隐私留存与税务别装死
- 隐私（GDPR/CCPA 思路）：账单与用量明细能导出、能删改敏感字段、能按策略过期；会计留存需要保留的部分用去标识化替代直接 PII。
- 税务：0→1 阶段优先接入税务服务或按单一法区起步，但你的发票模型必须能表达不同税率、免税资格、以及税额的可回算。
- 审计：所有税务与定价规则变更必须版本化，并能对历史账单回放。

### 多币种与汇率：先做单一币种，也要给未来留门
- 最简单策略：强制单一结算币种（例如 USD 或 CNY），但账本与发票都要显式写 `currency_code`，避免未来重构。
- 若必须换汇：在出账层做转换，并把 fx_rate 与生效时间写进发票（或引用 fx_rate_id）；不要在账本层混合币种金额。
- 金额存储：用最小币种单位整数 + 明确 rounding 规则，别用浮点数赌财务正确性。

## 风控与止损：把越用越亏关掉
风控的核心不是防坏人，也是防意外：脚本误刷、循环调用、批量任务误触发、模型异常导致重试风暴。

计费相关事故（重复计费、回调重放、对账差异、退款风暴）的 10 分钟止损手册见：[E-runbooks.md](E-runbooks.md)（RB-08）。

### 止损线建议作为门禁

| 场景 | 守门指标 | 阈值 | 越界动作 |
| --- | --- | --- | --- |
| 单用户异常 | 每分钟 token 消耗 / 日金额 | 不高于基线 × 1.5 | 限流/暂停/提示升级 |
| 租户异常 | 峰值 tool_calls / 日金额 | 不高于基线 × 1.3 | 降级高成本功能 |
| 全局尖峰 | 总消耗 / 错误率 | 不高于基线 × 1.3 | 临时关闭高风险入口 |

阈值不要拍脑袋，最低做法是先建立基线（过去 7 天分位数），再用倍数作为门槛；并区分告警阈值与阻断阈值。[6]

## 复现检查清单（本章最低门槛）
- 计量口径卡可审计：单位、计费时机、去重键、豁免、展示方式与争议处理口径写清楚。
- 账本事件不可变：event_id 唯一、幂等去重、支持冲正/补记，能追溯到一次行为与审计事件。[5]
- 最小对账可执行：按天汇总 + 抽样复核 + 异常告警，且能重跑复现一张账单/发票。[6]
- 出账可复现：按周期生成账单/发票，锁定币种与税版本，支持预览与导出明细；修正用冲正，不改历史。
- 止损线可触发：异常用量触发限流/暂停/降级，并记录原因与证据。[6]

## 常见陷阱（失败样本）
1. **现象：** 用户投诉多扣费，你无法解释，也无法证明自己算对了。  
   **根因：** 缺不可变账本/缺幂等去重；重试与重复回调被重复计费。[5][23]  
   **复现：** 人为触发一次支付回调重放或计量事件重放，观察同一 request_id 产生多笔费用。  
   **修复：** 账本事件唯一标识 + 幂等去重（固定 `idempotency_key`）+ 冲正机制；让每笔费用可追溯可重放。[5][23]  
   **回归验证：** 对“重复回调/重试风暴”回归用例，账本只追加不重复计费；对账可解释差异为 0。

2. **现象：** 用得越多越亏，现金流越好越危险；一波异常峰值直接把利润吃光。  
   **根因：** 订阅定价与成本脱钩；缺止损线与降级策略。[6]  
   **复现：** 让一个租户高频调用高成本链路（长上下文/工具链/多轮），观察单位成本超过定价覆盖范围且没有系统自动刹车。  
   **修复：** 加入用量上限或分层承诺；设置预算阈值 + 降级/限流/暂停策略；越界即止损并记录证据。[6]  
   **回归验证：** 在压力回归下（峰值/异常租户），止损规则可触发且可复盘：指标越界→动作生效→成本回到基线。

3. **现象：** 退款/拒付处理混乱，账目越修越乱；财务与工程口径对不上。  
   **根因：** 直接改历史账单/发票，而不是用冲正/补记；对账无法重放。[23]  
   **复现：** 为了纠错直接修改 invoice 行或覆盖聚合结果，导致同一周期的账单在不同时间导出不一致。  
   **修复：** 账本不可变：纠错用冲正/补记/credit_note；出账后锁定币种与税版本；对账与重算可重放。[23]  
   **回归验证：** 同一周期的账单在同口径复跑下结果一致；所有纠错都有对应事件与证据链，且能追溯到原因。

## 交付物清单与验收标准
- 定价模型说明与计量口径卡（含去重与豁免）。
- 账本事件规范（不可变、可追溯、可冲正）。[5][23]
- 出账与税务字段（账单/发票号、币种、税版本、导出明细）。
- 对账与止损规则（异常峰值可拦截）。[6]

## 下一章
计费解决怎么收钱，数据决定怎么变强。下一章进入数据收集与清洗：把语料变成可训练、可评测、可治理的数据资产。见：[13-data.md](13-data.md)。

## 参考
详见本书统一参考文献列表：[references.md](references.md)。
