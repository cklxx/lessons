# 序言：一人即是一支队伍

> AI 把“实现”这件事的边际成本压低了，但并没有自动抬高你的胜率：真正决定成败的，依然是决策质量、验证速度、以及你治理不确定性的能力。[2][4][18]

过去，“做出一个产品”往往意味着要凑齐一支队伍：有人做调研、有人写 PRD、有人画原型、有人写代码、有人做测试、有人上线运维。而现在，一个人也能在大幅压缩的周期内把这些环节串成闭环——前提是你把 AI 当作杠杆，而不是把它当作答案。

这篇序言想做两件事：第一，解释为什么“现在”是超级个体的窗口期；第二，给你一套可执行的工作纪律，助你在提速的同时，不被幻觉、漂移与熵增拖垮。[2][41]

## 为什么是现在：从“写代码”到“编排不确定性”

Transformer 奠定了可扩展的序列建模基础，而对齐/指令微调让模型更容易被人类以“指令 + 上下文”的方式驱动——你可以把它理解为一种更高层级的“可编程生产力”。[2][41]

与此同时，推理成本持续下降（例如通过更高效的推理路径与工程优化），让个人/小团队也能承担起“把模型放进真实系统”的成本曲线。[45] 但这并不意味着门槛消失：当你能更快地产出时，你也会更快地产出错误——如果没有证据与复现机制，你只是在更快地自欺欺人。[5][18]

## 重新定义“超级个体”：不是全能，而是端到端负责

本书所说的“超级个体”，不是指掌握所有语法与框架的“全栈”，而是指能对一个 AI 原生产品的端到端闭环负责：从机会验证、工程交付到质量/成本/风险的持续治理。[4][6]

你可以把成长路径理解为三个阶段（并非职业头衔，而是能力的叠加）：

1. **Caller（调用者）**：熟练使用 LLM，把 RAG/Agent 等范式组装成可用的原型；关注点是“把问题跑通”。典型交付物包括可演示的 Demo 与最小测试/验收项，而不是一堆提示词碎片。[24][29]
2. **Designer（设计者）**：开始把系统当系统来设计：架构分层、数据与权限边界、评测与防护栏、可观测与审计。典型交付物包括指标定义、失败样本集、审计日志口径与可回归的检查项。[5][34]
3. **Shaper（塑造者）**：在调用之外，能通过 SFT/DPO 等后训练手段塑造模型行为，形成可迁移、可积累的差异化能力。典型交付物包括权重/配置、对比基准与成本报告，而不是“据说更好了”。[40][42]

![图：超级个体的能力演进](../../assets/preface-super-individual-evolution.png)

| 阶段 | 你要对什么负责 | 交付物（最低门槛） |
|---|---|---|
| Caller | 功能闭环能演示 | Demo + 最小验收清单 |
| Designer | 质量/风险可控 | 指标定义 + 失败样本集 + 回滚预案 |
| Shaper | 行为可塑且可回归 | 数据/配置/权重 + 评测对比 + 成本报告 |

同时，你也是自己的 CFO：每一次调用、每一轮训练、每一张 GPU 账单，都要能解释投入产出与停止条件。云算力让你按需租用能力，也要求你显式化预算与能耗约束，避免“越迭代越亏”。[44]

## 本书提供什么：一套可复现的“个人开发操作系统”

请不要把本书当作“工具清单”或“代码片段合集”。工具会更迭，但范式与纪律更具生命力：模式优先、证据优先、复现优先。[18]

你会在正文里看到很多类似 `make xxx`、目录结构与 CI 检查的描述。需特别说明：**本仓库是文档站点，不包含完整工程源码**；这些命令与结构是“建议你落地到自己项目仓库的协议”，用于把复杂流程压缩成可执行的接口。[1][5]

这套“操作系统”由三类资产组成：

- **协议（Protocol）**：模板、约定、命名风格，让协作对象（未来的你、AI、或队友）能用同一套语言对齐。
- **证据（Evidence）**：基线对比、评测报告、日志与审计，让改动可证伪、可回滚。
- **闭环（Loop）**：把需求、实现、上线、评估串成固定节奏，避免“永远在做但从未完成”。[4]

## 工作纪律：无证据，不优化；无回归，不上线

AI 系统里最昂贵的不是写代码，而是“在不确定性里迷路”。为了不迷路，本书会反复强调两条纪律：

1. **无证据，不优化**：任何改动（Prompt、检索参数、训练配置、缓存策略）都必须有基线对比（质量/延迟/成本/风险）。没有数据支撑的“感觉更好”，应视为无效，需重新设计实验。[5][6]
2. **无回归，不上线**：你需要把失败样本当作一等公民：现象、根因、复现、修复、回归验证，形成可持续的“失败样本驱动”机制。[18]

当你把日志、Notebook、评测快照与决策记录一起放进版本控制，你得到的不只是“可复现”，而是一份可审计、可迁移的个人资产——它会在未来反复复利。[1][34]

## 实践节奏：每两周一个“最小可行叙事”（MVS）

本书建议用两周为一个迭代周期。周期结束时，你交付的不是“更多代码”，而是一段可验证的叙事：[4]

- **需求证据**：你为什么做它？证据来自哪里？反例是什么？
- **最小原型**：用户能体验到的最小闭环是什么？失败时如何降级？
- **上线指标**：你用什么指标证明它有效？数据从哪里来？阈值如何设定？
- **回滚预案**：退化了怎么办？回滚到哪里？如何确认已回滚？

如果你只做到其中两项，那就把它当作“未完成”，不要把“跑通”误认为“成功”。[18]

## 如何阅读本书

- 如果你正在从 0 到 1 做产品：优先读第一篇与第二篇（Ch01–Ch05），把“需求证据 → 交付 → 验收”闭环跑起来。
- 如果你已经有可用产品：优先读第三篇到第五篇（Ch06–Ch12），把“RAG/Agent/训练/部署/评估/治理”变成可回归、可演进的系统。

每章末尾的“交付物与验收”不是附录，而是你对自己工作的验收协议：参考执行，有助于获得可复制的结果；忽略它，则容易积累不可维护的债务。[5]

---

参考文献详见本书统一列表：[`references.md`](references.md)。
